<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[飞鸟-博客]]></title>
  <subtitle><![CDATA[学习技术，分享技术]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://fudawei.github.io//"/>
  <updated>2015-12-30T05:33:54.990Z</updated>
  <id>http://fudawei.github.io//</id>
  
  <author>
    <name><![CDATA[飞鸟]]></name>
    <email><![CDATA[764923019@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[Java并发包学习九]Java中的阻塞队列]]></title>
    <link href="http://fudawei.github.io/2015/10/23/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B9%9D-Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://fudawei.github.io/2015/10/23/Java并发包学习九-Java中的阻塞队列/</id>
    <published>2015-10-23T08:09:55.000Z</published>
    <updated>2015-12-30T05:33:54.990Z</updated>
    <content type="html"><![CDATA[<h1 id="什么是阻塞队列">什么是阻塞队列</h1><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<a id="more"></a>
<p>阻塞队列提供了四种处理方法:<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Java阻塞队列/阻塞队列方法.png" alt="Java中阻塞队列方法"></p>
<ul>
<li><strong>抛出异常</strong>：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li>
<li><strong>返回特殊值</strong>：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li>
<li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li>
<li><strong>超时退出</strong>：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li>
</ul>
<h1 id="Java里的阻塞队列">Java里的阻塞队列</h1><p>JDK7提供了7个阻塞队列。分别是</p>
<ol>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ol>
<h2 id="ArrayBlockingQueue">ArrayBlockingQueue</h2><p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span>  ArrayBlockingQueue(<span class="number">1000</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>访问者的公平性是使用可重入锁实现的，代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span>(<span class="params"><span class="keyword">int</span> capacity, boolean fair</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = <span class="keyword">lock</span>.newCondition();</span><br><span class="line">        notFull =  <span class="keyword">lock</span>.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedBlockingQueue">LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。此队列按照先进先出的原则对元素进行排序。</p>
<h2 id="PriorityBlockingQueue">PriorityBlockingQueue</h2><p>PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。</p>
<h2 id="DelayQueue">DelayQueue</h2><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：</p>
<ol>
<li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。<br>队列中的Delayed必须实现compareTo来指定元素的顺序。比如让延时时间最长的放在队列的末尾。实现代码如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;</span><br><span class="line">                ScheduledFutureTask x = (ScheduledFutureTask)other;</span><br><span class="line">                <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">                <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">                      other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">            <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ((d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何实现Delayed接口">如何实现Delayed接口</h3><p>我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类。这个类实现了Delayed接口。首先：在对象创建的时候，使用time记录前对象什么时候可以使用，代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledFutureTask</span>(<span class="type">Runnable</span> r, V <span class="literal">result</span>, long ns, long period) &#123;</span><br><span class="line">            super(r, <span class="literal">result</span>);</span><br><span class="line">            this.time = ns;</span><br><span class="line">            this.period = period;</span><br><span class="line">            this.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用getDelay可以查询当前元素还需要延时多久，代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为getDelay时可以指定任意单位，一旦以纳秒作为单位，而延时的时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。</p>
<h4 id="如何实现延时队列">如何实现延时队列</h4><p>延时队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long delay = first.getDelay<span class="params">(TimeUnit.NANOSECONDS)</span>;</span><br><span class="line">                    <span class="keyword">if</span> <span class="params">(delay &lt;= <span class="number">0</span>)</span></span><br><span class="line">                        return q.poll<span class="params">()</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(leader != null)</span></span><br><span class="line">                        available.await<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="SynchronousQueue">SynchronousQueue</h2><p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue 和 ArrayBlockingQueue。</p>
<h2 id="LinkedTransferQueue">LinkedTransferQueue</h2><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
<h3 id="transfer方法">transfer方法</h3><p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。transfer方法的关键代码如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node pred = tryAppend<span class="list">(<span class="keyword">s</span>, haveData)</span><span class="comment">;</span></span><br><span class="line">return awaitMatch<span class="list">(<span class="keyword">s</span>, pred, e, <span class="list">(<span class="keyword">how</span> == TIMED)</span>, nanos)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。</p>
<h3 id="tryTransfer方法">tryTransfer方法</h3><p>tryTransfer方法则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。</p>
<p>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p>
<h2 id="LinkedBlockingDeque">LinkedBlockingDeque</h2><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是Jdk的bug，使用时还是用带有First和Last后缀的方法更清楚。</p>
<p>在初始化LinkedBlockingDeque时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p>
<h1 id="阻塞队列的实现原理">阻塞队列的实现原理</h1><p>如果队列是空的，消费者会一直等待，当生产者添加元素时候，消费者是如何知道当前队列有元素的呢？如果让你来设计阻塞队列你会如何设计，让生产者和消费者能够高效率的进行通讯呢？让我们先来看看JDK是如何实现的。</p>
<p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现ArrayBlockingQueue使用了Condition来实现，代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final Condition notFull;</span><br><span class="line"><span class="keyword">private</span> final Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span>(<span class="params"><span class="keyword">int</span> capacity, boolean fair</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">        notEmpty = <span class="keyword">lock</span>.newCondition();</span><br><span class="line">        notFull =  <span class="keyword">lock</span>.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">        <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">        final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">        <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> extract();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span>(<span class="params">E x</span>) </span>&#123;</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        putIndex = inc(putIndex);</span><br><span class="line">        ++count;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过LockSupport.park(this)来实现</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final void await<span class="params">()</span> throws InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(Thread.interrupted<span class="params">()</span>)</span></span><br><span class="line">                throw new InterruptedException<span class="params">()</span>;</span><br><span class="line">            Node node = addConditionWaiter<span class="params">()</span>;</span><br><span class="line">            int savedState = fullyRelease<span class="params">(node)</span>;</span><br><span class="line">            int interruptMode = <span class="number">0</span>;</span><br><span class="line">            while <span class="params">(!isOnSyncQueue<span class="params">(node)</span>)</span> &#123;</span><br><span class="line">                LockSupport.park<span class="params">(this)</span>;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(<span class="params">(interruptMode = checkInterruptWhileWaiting<span class="params">(node)</span>)</span> != <span class="number">0</span>)</span></span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(acquireQueued<span class="params">(node, savedState)</span> &amp;&amp; interruptMode != THROW_IE)</span></span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(node.nextWaiter != null)</span> <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters<span class="params">()</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(interruptMode != <span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line">reportInterruptAfterWait<span class="params">(interruptMode)</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>继续进入源码，发现调用setBlocker先保存下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span>(<span class="params">Object blocker</span>) </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        <span class="keyword">unsafe</span>.park(<span class="keyword">false</span>, <span class="number">0</span>L);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>unsafe.park是个native方法，代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure>
<p>park这个方法会阻塞当前线程，只有以下四种情况中的一种发生时，该方法才会返回。</p>
<ul>
<li>与park对应的unpark执行或已经执行时。注意：已经执行是指unpark先执行，然后再执行的park。</li>
<li>线程被中断时。</li>
<li>如果参数中的time不是零，等待了指定的毫秒数时。</li>
<li>发生异常现象时。这些异常事先无法确定。</li>
</ul>
<p>我们继续看一下JVM是如何实现park方法的，park在不同的操作系统使用不同的方式实现，在linux下是使用的是系统方法pthread_cond_wait实现。实现代码在JVM源码路径src/os/linux/vm/os_linux.cpp里的 os::PlatformEvent::park方法，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> os::PlatformEvent::park() &#123;      </span><br><span class="line">             <span class="keyword">int</span> v ;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        v = _Event ;</span><br><span class="line">         <span class="keyword">if</span> (Atomic::cmpxchg (v-<span class="number">1</span>, &amp;_Event, v) == v) <span class="keyword">break</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         guarantee (v &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">         <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// Do this the hard way by blocking ...</span></span><br><span class="line">         <span class="keyword">int</span> status = pthread_mutex_lock(_mutex);</span><br><span class="line">         assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_lock"</span>);</span><br><span class="line">         guarantee (_nParked == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">         ++ _nParked ;</span><br><span class="line">         <span class="keyword">while</span> (_Event &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         status = pthread_cond_wait(_cond, _mutex);</span><br><span class="line">         <span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...</span></span><br><span class="line">         <span class="comment">// Treat this the same as if the wait was interrupted</span></span><br><span class="line">         <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;</span><br><span class="line">         assert_status(status == <span class="number">0</span> || status == EINTR, status, <span class="string">"cond_wait"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         -- _nParked ;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),</span></span><br><span class="line">         <span class="comment">// but then we'd need a MEMBAR after the ST.</span></span><br><span class="line">         _Event = <span class="number">0</span> ;</span><br><span class="line">         status = pthread_mutex_unlock(_mutex);</span><br><span class="line">         assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_unlock"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         guarantee (_Event &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>pthread_cond_wait是一个多线程的条件变量函数，cond是condition的缩写，字面意思可以理解为线程在等待一个条件发生，这个条件是一个全局变量。这个方法接收两个参数，一个共享变量_cond，一个互斥量_mutex。而unpark方法在linux下是使用pthread_cond_signal实现的。park 在windows下则是使用WaitForSingleObject实现的。</p>
<p>当队列满时，生产者往阻塞队列里插入一个元素，生产者线程会进入WAITING (parking)状态。我们可以使用jstack dump阻塞的生产者线程看到这点：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007fc83c000000 nid=<span class="number">0</span>x10164e000 waiting on condition [<span class="number">0</span>x000000010164d000]</span><br><span class="line">   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: WAITING (parking)</span><br><span class="line">        at sun<span class="class">.misc</span><span class="class">.Unsafe</span><span class="class">.park</span>(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0</span>x0000000140559fe8&gt; (<span class="tag">a</span> java<span class="class">.util</span><span class="class">.concurrent</span><span class="class">.locks</span><span class="class">.AbstractQueuedSynchronizer</span><span class="variable">$ConditionObject</span>)</span><br><span class="line">        at java<span class="class">.util</span><span class="class">.concurrent</span><span class="class">.locks</span><span class="class">.LockSupport</span><span class="class">.park</span>(LockSupport<span class="class">.java</span>:<span class="number">186</span>)</span><br><span class="line">        at java<span class="class">.util</span><span class="class">.concurrent</span><span class="class">.locks</span><span class="class">.AbstractQueuedSynchronizer</span><span class="variable">$ConditionObject</span>.<span class="function"><span class="title">await</span><span class="params">(AbstractQueuedSynchronizer.java:<span class="number">2043</span>)</span></span></span><br><span class="line">        at java<span class="class">.util</span><span class="class">.concurrent</span><span class="class">.ArrayBlockingQueue</span><span class="class">.put</span>(ArrayBlockingQueue<span class="class">.java</span>:<span class="number">324</span>)</span><br><span class="line">        at blockingqueue<span class="class">.ArrayBlockingQueueTest</span><span class="class">.main</span>(ArrayBlockingQueueTest<span class="class">.java</span>:<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<h1 id="声明">声明</h1><p>本文转载自：<a href="http://www.infoq.com/cn/articles/java-blocking-queue/" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-blocking-queue/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="什么是阻塞队列">什么是阻塞队列</h1><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>]]>
    
    </summary>
    
      <category term="Java并发包学习" scheme="http://fudawei.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Java并发包学习" scheme="http://fudawei.github.io/categories/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wait,notify,notifyAll详细介绍]]></title>
    <link href="http://fudawei.github.io/2015/10/23/wait-notify-notifyAll%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fudawei.github.io/2015/10/23/wait-notify-notifyAll详细介绍/</id>
    <published>2015-10-23T06:05:18.000Z</published>
    <updated>2015-12-30T06:02:16.188Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>wait，notify和notifyAll方法是Object类的成员函数，所以Java的任何一个对象都能够调用这三个方法。这三个方法主要是用于线程间通信，协调多个线程的运行。</p>
<a id="more"></a>
<h1 id="wait函数">wait函数</h1><p>调用线程的sleep，yield方法时，线程并不会让出对象锁，wait却不同。</p>
<p><strong>wait函数必须在同步代码块中调用(也就是当前线程必须持有对象的锁)</strong>，他的功能是这样的：</p>
<blockquote>
<p>我累了，休息一会儿，对象的锁你们拿去用吧，CPU也给你们。</p>
</blockquote>
<p>调用了wait函数的线程会一直等待，直到有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立即获得对象的锁。也就是说，一个线程调用了对象的wait方法后，他需要等待两件事情的发生：</p>
<ol>
<li>有其他线程调用同一个对象的notify或者notifyAll方法（调用notify/notifyAll方法之前）</li>
<li>被唤醒之后重新获得对象的锁(调用notify/notifyAll方法之后)</li>
</ol>
<p>才能继续往下执行后续动作。</p>
<p>如果一个线程调用了某个对象的wait方法，但是后续并没有其他线程调用该对象的notify或者notifyAll方法，则该线程将会永远等下去…</p>
<h1 id="notify和notifyAll方法">notify和notifyAll方法</h1><p><strong>notofy/notifyAll方法也必须在同步代码块中调用(也就是调用线程必须持有对象的锁)</strong>，他们的功能是这样的：</p>
<blockquote>
<p>女士们，先生们请注意，锁的对象我即将用完，请大家醒醒，准备一下，马上你们就能使用锁了。</p>
</blockquote>
<p>不同的是，notify方法只会唤醒一个正在等待的线程(至于唤醒谁，不确定！)，而notifyAll方法会唤醒所有正在等待的线程。还有一点需要特别强调：<strong>调用notify和notifyAll方法后，当前线程并不会立即放弃锁的持有权，而必须要等待当前同步代码块执行完才会让出锁。</strong></p>
<p>如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。</p>
<h1 id="小试牛刀">小试牛刀</h1><p>下面我们举例子来巩固上面讲到的理论知识,下面的代码创建了两个线程，Thread1在同步代码块中调用wait，Thread2在同步代码块中调用notify：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.winwill.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> 飞鸟</span><br><span class="line"> * <span class="doctag">@date</span> 15/8/14 16:37</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread1 start..."</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread1 stop..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread2 start..."</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(<span class="string">"Thread2 stop..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<blockquote>
<p>Thread1 start…<br>Thread2 start…<br>Thread2 stop…<br>Thread1 stop…  </p>
</blockquote>
<p>从上面的例子可以证实上面说到的一个结论：<strong>线程调用notify方法后并不会让出锁，而必须等待同步代码块执行完毕之后再让出</strong>，可以看到执行结果中Thread2的开始和结束是成对挨着出现的。</p>
<h1 id="总结">总结</h1><p>这三个函数的相互通信可以做很多事情，比如常见的生产者-消费者模式，生产者要往队列里面生产东西，就必须等待队列有空间，同样的，消费者要同队列里面消费东西，就必须等待队列里有东西。使用wait,notify,notifyAll方法可以协调生产者和消费者之间的行为。在JDK1.4之后出现了一个Condition类，这个类也能够实现相同的功能，并且一般建议使用Condition替代wait,notify,notifyAll家族，实现更安全的线程间通信功能，比如ArrayBlockingQueue就是使用Condition实现阻塞队列的。</p>
<h1 id="声明">声明</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/10/23/wait-notify-notifyAll%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/">http://fudawei.github.io/2015/10/23/wait-notify-notifyAll%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>wait，notify和notifyAll方法是Object类的成员函数，所以Java的任何一个对象都能够调用这三个方法。这三个方法主要是用于线程间通信，协调多个线程的运行。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://fudawei.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://fudawei.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[皆大欢喜的加薪]]></title>
    <link href="http://fudawei.github.io/2015/10/23/%E7%9A%86%E5%A4%A7%E6%AC%A2%E5%96%9C%E7%9A%84%E5%8A%A0%E8%96%AA/"/>
    <id>http://fudawei.github.io/2015/10/23/皆大欢喜的加薪/</id>
    <published>2015-10-23T04:47:28.000Z</published>
    <updated>2015-12-30T05:33:54.986Z</updated>
    <content type="html"><![CDATA[<p> 我的朋友A君是个典型的.NET开发人员，技术不错，人品也不错，在一家小公司（姑且称为甲公司）做项目开发，是技术骨干。3个月前，他找到我说想跳槽，让我帮忙介绍工作。我说为什么想跳了？</p>
<a id="more"></a>
<h2 id="为什么想离职？">为什么想离职？</h2><p>他简单说了一下他在甲公司当时的状况：A君在甲公司做了两年多，这两年多完成了一个大项目，作为开发的核心主力，开发压力很大，特别是项目上线前的几个月是非常辛苦，几乎每晚都要加班到12点以后，周末最多只有一天休息。在最困难的时候，老板给大家大气，“大家再坚持坚持，项目上线赚钱了，就给大家涨工资，公司是绝对不会亏待大家的”，在老板豪情壮语的加薪鼓励下，大家要紧牙关拼上了。终于，半年前，项目上线了，运行也慢慢稳定了，公司赚钱也多了起来。</p>
<p>是的，公司赚钱了，利润很可观，这是大家都知道的事情。但是，一两个月过去了，加薪的事情完全没影，老板就像从来没提过一样。于是，A君向人事经理说出了希望加薪的请求，最后，得到的回复（在小公司，这当然是老板的意思）:</p>
<ol>
<li>A君目前的工资与外面相比，基本是持平的。</li>
<li>A君目前的工作很悠闲，工作量不饱和。</li>
</ol>
<p>关于1实际上是个难题，两个人的工资要怎么比较，几乎都是老板一个非常主观的想法。而关于2，却是事实：由于新的项目还在调研中，所以，A君的工作暂时就轻松了不少，主要就是维护线上的系统，加加小功能，修修小bug，比较清闲。</p>
<h2 id="老板很有骨气">老板很有骨气</h2><p>A君听到回复后，很是生气，在和同事们一起吃饭时，就忍不住埋怨起公司来，后来，这话传到了老板的耳朵里，老板很有骨气：越是抱怨，越不给你涨工资，看你怎么样。<br>终于，A决定离职，老板一如既往的有骨气：离职就离职，离开你公司就得关门了？<br>所以，就回到了开头的一幕，3个月前，A要我帮忙介绍工作。我刚好想到之前另外一个乙公司的技术经理联系我说，他下面有个B君想离职，希望我推荐个人，事成之后有推荐费拿的。理所当然的，我把A推荐了到了乙公司，A接手了B君的工作（在接手的过程中，A和B还成为了好朋友），乙公司对A的表现非常满意，最后，A的工资相比在甲公司涨幅达到50%。</p>
<h2 id="对调一下吧">对调一下吧</h2><p>事情还没完，A君从甲公司离职后，甲公司的线上系统的维护就成为一个大问题了，老板命令人事经理赶快找人来顶上，苦逼的人事经理在QQ里群发了招聘的信息，这个信息也发给了A君，于是，A君把正在找工作的B君推荐过去了。B君在甲公司工作一个月后就转正，老板也很满意，相比之前在乙公司工资上涨了30%，和现在A的工资差不多。</p>
<p> —— 后来，A告诉我，B之所以要离职，原因跟A是差不多的。</p>
<h2 id="皆大欢喜">皆大欢喜</h2><p>这真是一个皆大欢喜的局面！</p>
<ol>
<li>A到乙公司接手了原来B的工作，工资涨了50%。</li>
<li>B到甲公司接手了原来A的工作，工资涨了30%。</li>
<li>更重要的是，甲、乙公司的老板都爽了，对新进来的员工的表现都非常满意。</li>
<li>而我，拿到了乙公司的推荐费。</li>
<li>A和B成为了好朋友，除了经常探讨技术外，还经常一起讨论这搞笑的离职加薪过程，交流心得。</li>
</ol>
<h2 id="声明">声明</h2><p>尊重原创，本文转载自：<a href="http://www.cnblogs.com/justnow/p/4903436.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://www.cnblogs.com/justnow/p/4903436.html?utm_source=tuicool&amp;utm_medium=referral</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 我的朋友A君是个典型的.NET开发人员，技术不错，人品也不错，在一家小公司（姑且称为甲公司）做项目开发，是技术骨干。3个月前，他找到我说想跳槽，让我帮忙介绍工作。我说为什么想跳了？</p>]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://fudawei.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="杂谈" scheme="http://fudawei.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis主从复制]]></title>
    <link href="http://fudawei.github.io/2015/10/18/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://fudawei.github.io/2015/10/18/Redis主从复制/</id>
    <published>2015-10-18T05:41:12.000Z</published>
    <updated>2015-12-30T06:02:16.180Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：  </p>
<ol>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内容容量为256G，也不能将所有内容用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过<strong>20G</strong>。</li>
</ol>
<p>本文先讨论第一点的解决方案：<strong>Redis主从复制</strong>，第二点可以使用Redis集群解决，下一篇文章将介绍Redis集群。<br><a id="more"></a></p>
<h1 id="主从复制">主从复制</h1><p>考虑如下一种场景：</p>
<blockquote>
<p>电子商务网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
</blockquote>
<p>对于这种场景，我们可以使如下这种架构：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/主从复制架构.png" alt="Redis主从复制结构图"></p>
<p>如图中所示，我们将一台Redis服务器作主库(Matser)，其他三台作为从库(Slave)，主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处：</p>
<ol>
<li>读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量，棒极了；</li>
<li>数据被复制成了了好几份，就算有一台机器出现故障，也可以使用其他机器的数据快速恢复。</li>
</ol>
<p>需要注意的是：在Redis主从模式中，一台主库可以拥有多个从库，但是一个从库只能隶属于一个主库。</p>
<h1 id="配置">配置</h1><p>在Redis中，要实现主从复制架构非常简单，只需要在从数据库的配置文件中加上如下命令即可：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">slaveof</span> 主数据库地址  主数据库端口</span><br></pre></td></tr></table></figure>
<p>主数据库不需要任何配置。</p>
<h1 id="示例">示例</h1><p>下面将演示怎么实现一个简单的复制系统。我们在一台机器上起两个Redis实例，监听不同的端口，其中一个作为主库，另外一个作为从库。首先不加任何参数来启动一个Redis实例作为主数据库：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/启动主库.png" alt=""><br>可以看到，主库监听的是6379端口。</p>
<p>然后加上slaveof参数启动另一个Redis实例作为从库，并且监听6380端口：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/启动从库.png" alt=""><br>从控制台输出中可以看到，从库已经连接到主库：126.0.0.1:6379了，看样子主从复制系统配置成功。我们可以分别在主库和从库中使用如下命令看一看当前实例在复制系统中的相关信息：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/Redis角色.png" alt=""></p>
<p>接下来验证一把。</p>
<p>首先在主库中设置一个键值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac~]$ /opt/soft/redis-<span class="number">3.0</span><span class="number">.4</span>/src/redis-cli -p <span class="number">6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> test-sync 飞鸟</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>现在到从库中检查该值是否已经自动同步到了从库：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac~]$ /opt/soft/redis-<span class="number">3.0</span><span class="number">.4</span>/src/redis-cli -p <span class="number">6380</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; get test-sync</span><br><span class="line"><span class="string">"飞鸟"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，数据确实从主库同步到了从库.</p>
<p>在默认情况下，从库是只读的，如果在从库中写数据将会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac~]$ /opt/soft/redis-<span class="number">3.0</span><span class="number">.4</span>/src/redis-cli -p <span class="number">6380</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="function"><span class="built_in">set</span> x <span class="title">y</span></span><br><span class="line"><span class="params">(error)</span> READONLY You can't write against a read only slave.</span><br><span class="line">127.0.0.1:6380&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是可以在从库的配置文件中加上如下的配置项允许从库写数据：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-<span class="keyword">read</span>-<span class="keyword">only</span> <span class="keyword">no</span></span><br></pre></td></tr></table></figure>
<p>但是，因为从库中修改的数据不会被同步到任何其他数据库，并且一旦主库修改了数据，从库的数据就会因为自动同步被覆盖，所以一般情况下，不建议将从库设置为可写。</p>
<p>相同的道理，配置多台从库也使用相同的方法，都在从库的配置文件中加上slaveof参数即可。</p>
<p>此外，我们可以在客户端使用命令</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">SLAVEOF</span> 新主库地址  新主库端口</span><br></pre></td></tr></table></figure>
<p>来修改当前数据库的主库，如果当前数据库已经是其他库的从库， 则当前数据库会停止和原来的数据库的同步而和新的数据库同步。</p>
<p>最后，从数据库还可以通过运行命令：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SL<span class="built_in">AVEOF</span> <span class="literal">NO</span> ONE</span><br></pre></td></tr></table></figure>
<p>来停止接受来自其他数据库的同步而升级成为主库。</p>
<h1 id="原理">原理</h1><p>上面说了配置主从复制系统的方法，并且举例例子详细说明，本节将介绍Redis主从复制的实现原理。</p>
<p>当一个从数据库启动时，会向主数据库发送SYNC命令，主数据库收到命令后会开始在后台保存快照（即RDB持久化过程），并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和缓存的命令发给从数据库，从数据库收到数据后，会载入快照文件并执行缓存的命令。以上过程称为<strong>复制初始化</strong>。复制初始化之结束后，主数据库每收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致，这一过程称为<strong>复制同步阶段</strong>。</p>
<p>有两点需要注意：</p>
<ol>
<li>当主从数据库之间的连接断开后，Redis2.8之前的版本会重新进行复制初始化过程，这样就使得主从数据库断开连接后数据恢复的过程的效率很低下。Redis2.8版本的一个重要改进就是断线支持有条件的增量数据传输，当从数据库再次连接到主数据库时，主数据库只需要将断线期间执行的命令发给从数据库即可，大大提高了Redis主从复制的实用性。</li>
<li>复制同步阶段贯穿整个主从同步过程的始终，直到主从关系终止为止。在复制过程中，即使关闭了RDB方式的持久化(删除所有save参数)，依旧会执行快照操作。</li>
</ol>
<h1 id="乐观复制">乐观复制</h1><p>Redis采用了复制的策略。容忍在一定时间内主从数据库的内容是不同的，但是两者的数据最终会保持一致。具体来说，Redis主从数据库之间的复制数据的过程本身是异步的，这意味着，主数据库执行完客户端的写请求后会立即将命令在主数据库的执行结果返回给客户端，而不会等待从数据库收到该命令后再返回给客户端。这一特性保证了复制后主从数据库的性能不会受到影响，但另一方面也会产生一个主从数据库数据不一致的时间窗口，当主数据库执行一条写命令之后，主数据库的数据已经发生变动，然而在主数据库将该命令传送给从数据库之前，如果两个数据库之间的连接断开了，此时二者间的数据就不一致了。从这个角度看，主数据库无法得知命令最终同步给了几个从数据库，不过Redis提供了两个配置选项来限制只有至少同步给指定数量的数据库时，主数据库才是可写的：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">min</span>-slave2-<span class="built_in">max</span>-lag <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>第一个参数表示只有当3个或3个以上的从数据库连接到主库时，主数据库才是可写的，否则返回错误。<br>第二个参数表示允许从数据库失去连接的最长时间，该选项默认是关闭的，在分布式系统中，打开并合理配置该选项可以降低主从架构因为网络分区导致的数据不一致问题。</p>
<h1 id="图结构">图结构</h1><p>从数据库不仅可以接收主数据库的数据，同时也可以作为主数据库存在，形成类似图的结构，如下图：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/图结构.png" alt=""><br>A中的数据会同步到B,C中，C中的数据会同步到D,E中。</p>
<h1 id="声明">声明</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/10/18/Redis主从复制">http://fudawei.github.io/2015/10/18/Redis主从复制</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：  </p>
<ol>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内容容量为256G，也不能将所有内容用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过<strong>20G</strong>。</li>
</ol>
<p>本文先讨论第一点的解决方案：<strong>Redis主从复制</strong>，第二点可以使用Redis集群解决，下一篇文章将介绍Redis集群。<br>]]>
    
    </summary>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/tags/Redis/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/categories/Redis/"/>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/categories/Redis/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis持久化]]></title>
    <link href="http://fudawei.github.io/2015/10/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://fudawei.github.io/2015/10/13/Redis持久化/</id>
    <published>2015-10-12T16:16:02.000Z</published>
    <updated>2015-12-30T06:02:16.176Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>Redis的强大性能很大程度上都是因为所有数据都是存储在内存中的，然而当Redis重启后，所有存储在内存中的数据将会丢失，在很多情况下是无法容忍这样的事情的。所以，我们需要将内存中的数据持久化！典型的需要持久化数据的场景如下：</p>
<ul>
<li>将Redis作为数据库使用；</li>
<li>将Redis作为缓存服务器使用，但是缓存miss后会对性能造成很大影响，所有缓存同时失效时会造成服务雪崩，无法响应。</li>
</ul>
<a id="more"></a>
<p>本文介绍Redis所支持的两种数据持久化方式。</p>
<h1 id="Redis数据持久化">Redis数据持久化</h1><p>Redis支持两种数据持久化方式：RDB方式和AOF方式。前者会根据配置的规则定时将内存中的数据持久化到硬盘上，后者则是在每次执行写命令之后将命令记录下来。两种持久化方式可以单独使用，但是通常会将两者结合使用。</p>
<h2 id="RDB方式">RDB方式</h2><p>RDB方式的持久化是通过快照的方式完成的。当符合某种规则时，会将内存中的数据全量生成一份副本存储到硬盘上，这个过程称作”快照”，Redis会在以下几种情况下对数据进行快照：</p>
<ul>
<li>根据配置规则进行自动快照；</li>
<li>用户执行SAVE, BGSAVE命令；</li>
<li>执行FLUSHALL命令；</li>
<li>执行复制（replication）时。</li>
</ul>
<h3 id="执行快照的场景">执行快照的场景</h3><h4 id="根据配置自动快照">根据配置自动快照</h4><p>Redis允许用户自定义快照条件，当满足条件时自动执行快照，快照规则的配置方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>每个快照条件独占一行，他们之间是或（||）关系，只要满足任何一个就进行快照。上面配置save后的第一个参数T是时间，单位是秒，第二个参数M是更改的键的个数，含义是：当时间T内被更改的键的个数大于M时，自动进行快照。比如<code>save 900 1</code>的含义是15分钟内(900s)被更改的键的个数大于1时，自动进行快照操作。</p>
<h4 id="执行SAVE或BGSAVE命令">执行SAVE或BGSAVE命令</h4><p>除了让Redis自动进行快照外，当我们需要重启，迁移，备份Redis时，我们也可以手动执行SAVE或BGSAVE命令主动进行快照操作。</p>
<ul>
<li><strong>SAVE命令：</strong>当执行SAVE命令时，Redis同步进行快照操作，期间会阻塞所有来自客户端的请求，所以放数据库数据较多时，应该避免使用该命令；</li>
<li><strong>BGSAVE命令：</strong> 从命令名字就能看出来，这个命令与SAVE命令的区别就在于该命令的快照操作是在后台异步进行的，进行快照操作的同时还能处理来自客户端的请求。执行BGSAVE命令后Redis会马上返回OK表示开始进行快照操作，如果想知道快照操作是否已经完成，可以使用LASTSAVE命令返回最近一次成功执行快照的时间，返回结果是一个Unix时间戳。</li>
</ul>
<h4 id="执行FLUSHALL命令">执行FLUSHALL命令</h4><p>当执行FLUSHALL命令时，Redis会清除数据库中的所有数据。需要注意的是：<strong>不论清空数据库的过程是否触发 了自动快照的条件，只要自动快照条件不为空，Redis就会执行一次快照操作，当没有定义自动快照条件时，执行FLUSHALL命令不会进行快照操作。</strong></p>
<h4 id="执行复制">执行复制</h4><p>当设置了主从模式时，Redis会在复制初始化是进行自动快照。</p>
<h3 id="快照原理">快照原理</h3><p>Redis默认会将快照文件存储在Redis当前进程的工作目录的dump.rdb文件中，可以通过配置文件中的dir和dbfilename两个参数分别指定快照文件的存储路径和文件名，例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dbfilename <span class="keyword">dump</span>.rdb</span><br><span class="line">dir <span class="regexp">/opt/</span>soft<span class="regexp">/redis-3.0.4/</span>cache</span><br></pre></td></tr></table></figure>
<p>快照执行的过程如下：</p>
<ol>
<li>Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；</li>
<li>父进程继续处理来自客户端的请求，子进程开始将内存中的数据写入硬盘中的临时文件；</li>
<li>当子进程写完所有的数据后，用该临时文件替换旧的RDB文件，至此，一次快照操作完成。</li>
</ol>
<p>需要注意的是：  </p>
<blockquote>
<p><strong>在执行fork是时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻，父进程和子进程共享同一块内存数据，当父进程需要修改其中的某片数据（如执行写命令）时，操作系统会将该片数据复制一份以保证子进程不受影响，所以RDB文件存储的是执行fork操作那一刻的内存数据。所以RDB方式理论上是会存在丢数据的情况的(fork之后修改的的那些没有写进RDB文件)。</strong></p>
</blockquote>
<p>通过上述的介绍可以知道，快照进行时时不会修改RDB文件的，只有完成的时候才会用临时文件替换老的RDB文件，所以就保证任何时候RDB文件的都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据的备份。RDB文件是经过压缩处理的二进制文件，所以占用的空间会小于内存中数据的大小，更有利于传输。</p>
<p>Redis启动时会自动读取RDB快照文件，将数据从硬盘载入到内存，根据数量的不同，这个过程持续的时间也不尽相同，通常来讲，一个记录1000万个字符串类型键，大小为1GB的快照文件载入到内存需要20-30秒的时间。</p>
<h3 id="示例">示例</h3><p>下面演示RDB方式持久化，首先使用配置有如下快照规则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir /opt/soft/redis-<span class="number">3.0</span><span class="number">.4</span>/cache</span><br></pre></td></tr></table></figure>
<p>的配置文件<code>/opt/soft/redis-3.0.4/conf/redis.conf</code>启动Redis服务：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis持久化/start-redis.png" alt="">  </p>
<p>然后通过客户端设置一个键值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac~]$ /opt/soft/redis-<span class="number">3.0</span><span class="number">.4</span>/src/redis-cli -p <span class="number">6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> test-rdb HelloWorld</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get test-rdb</span><br><span class="line"><span class="string">"HelloWorld"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>现在强行kill Redis服务：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis持久化/stop-redis.png" alt=""><br>现在到<code>/opt/soft/redis-3.0.4/cache</code>目录看，目录下出现了Redis的快照文件dump.rdb：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac<span class="regexp">/opt/</span>soft<span class="regexp">/redis-3.0.4/</span>cache]$ ls</span><br><span class="line"><span class="keyword">dump</span>.rdb</span><br></pre></td></tr></table></figure>
<p>现在重新启动Redis：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis持久化/start-redis.png" alt="">  </p>
<p>然后再用客户端连接，检查之前设置的key是否还存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac~]$ /opt/soft/redis-<span class="number">3.0</span><span class="number">.4</span>/src/redis-cli -p <span class="number">6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get test-rdb</span><br><span class="line"><span class="string">"HelloWorld"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现，之前设置的key在Redis重启之后又通过快照文件dump.rdb恢复了。</p>
<h2 id="AOF方式">AOF方式</h2><p>在使用Redis存储非临时数据时，一般都需要打开AOF持久化来降低进程终止导致的数据丢失，AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这已过程显然会降低Redis的性能，但是大部分情况下这个影响是可以接受的，另外，使用较快的硬盘能提高AOF的性能。</p>
<h3 id="开启AOF">开启AOF</h3><p>默认情况下，Redis没有开启AOF（append only file）持久化功能，可以通过在配置文件中作如下配置启用：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">appendonly</span> <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>开启之后，Redis每执行一条写命令就会将该命令写入硬盘中的AOF文件。AOF文件保存路径和RDB文件路径是一致的，都是通过dir参数配置，默认文件名是：appendonly.aof，可以通过配置appendonlyfilename参数修改，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">appendonlyfilename</span> <span class="tag">appendonly</span><span class="class">.aof</span></span><br></pre></td></tr></table></figure>
<h3 id="AOF持久化的实现">AOF持久化的实现</h3><p>AOF纯文本的形式记录了Redis执行的写命令，例如在开启AOF持久化的情况下执行如下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac/opt/soft/redis-<span class="number">3.0</span><span class="number">.4</span>]$ ./src/redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> aof1 value1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> aof2 value2</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>然后查看<code>/opt/soft/redis-3.0.4/cache/appendonly.aof</code>文件：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac/opt/soft/redis-<span class="number">3.0</span>.<span class="number">4</span>/cache]$ cat appendonly.aof</span><br><span class="line">*<span class="number">2</span></span><br><span class="line"><span class="variable">$6</span></span><br><span class="line">SELECT</span><br><span class="line"><span class="variable">$1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">*<span class="number">3</span></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">set</span><br><span class="line"><span class="variable">$4</span></span><br><span class="line">aof1</span><br><span class="line"><span class="variable">$6</span></span><br><span class="line">value1</span><br><span class="line">*<span class="number">3</span></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">set</span><br><span class="line"><span class="variable">$4</span></span><br><span class="line">aof2</span><br><span class="line"><span class="variable">$6</span></span><br><span class="line">value2</span><br></pre></td></tr></table></figure>
<p>文件中的内容正是Redis刚才执行的命令的内容，内容的格式就先不展开叙述了。</p>
<h3 id="AOF文件重写">AOF文件重写</h3><p>假设Redis执行了如下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac/opt/soft/redis-<span class="number">3.0</span><span class="number">.4</span>]$ ./src/redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k v2</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k v3</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果这所有的命令都写到AOF文件的话，将是一个比较蠢行为，因为前面两个命令会被第三个命令覆盖，所以AOF文件完全不需要保存前面两个文件，事实上Redis确实就是这么做的。删除AOF文件中无用的命令的过程成为”AOF重写”，AOF重写可以在配置文件中做相应的配置，当满足配置的条件时，自动进行AOF重写操作。配置如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>
<p>第一行的意思是，目前的AOF文件的大小超过上一次重写时的AOF文件的百分之多少时再次进行重写，如果之前没有重写过，则以启动时AOF文件大小为依据。<br>第二行的意思是，当AOF文件的大小大于64MB时才进行重写，因为如果AOF文件本来就很小时，有几个无效的命令也是无伤大雅的事情。<br>这两个配置项通常一起使用。</p>
<p>我们还可以手动执行BDREWRITEAOF命令主动让Redis重写AOF文件，执行重写命令之后查看现在的AOF文件：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac/opt/soft/redis-<span class="number">3.0</span>.<span class="number">4</span>]$ cat cache/appendonly.aof</span><br><span class="line">*<span class="number">2</span></span><br><span class="line"><span class="variable">$6</span></span><br><span class="line">SELECT</span><br><span class="line"><span class="variable">$1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">*<span class="number">3</span></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">SET</span><br><span class="line"><span class="variable">$4</span></span><br><span class="line">aof2</span><br><span class="line"><span class="variable">$6</span></span><br><span class="line">value2</span><br><span class="line">*<span class="number">3</span></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">SET</span><br><span class="line"><span class="variable">$1</span></span><br><span class="line">k</span><br><span class="line"><span class="variable">$2</span></span><br><span class="line">v3</span><br><span class="line">*<span class="number">3</span></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">SET</span><br><span class="line"><span class="variable">$4</span></span><br><span class="line">aof1</span><br><span class="line"><span class="variable">$6</span></span><br><span class="line">value1</span><br></pre></td></tr></table></figure>
<p>可以看到，文件中并没有再记录<code>set k v1</code>这样的无效命令。</p>
<h3 id="同步硬盘数据">同步硬盘数据</h3><p>虽然每次执行更改数据库的内容时，AOF都会记录执行的命令，但是由于操作系统本身的硬盘缓存的缘故，AOF文件的内容并没有真正地写入硬盘，在默认情况下，操作系统会每隔30s将硬盘缓存中的数据同步到硬盘，但是为了防止系统异常退出而导致丢数据的情况发生，我们还可以在Redis的配置文件中配置这个同步的频率：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="preprocessor"># appendfsync no</span></span><br></pre></td></tr></table></figure>
<p>第一行表示每次AOF写入一个命令都会执行同步操作，这是最安全也是最慢的方式；<br>第二行表示每秒钟进行一次同步操作，一般来说使用这种方式已经足够；<br>第三行表示不主动进行同步操作，这是最不安全的方式。</p>
<h1 id="声明">声明</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/10/13/Redis持久化">http://fudawei.github.io/2015/10/13/Redis持久化</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>Redis的强大性能很大程度上都是因为所有数据都是存储在内存中的，然而当Redis重启后，所有存储在内存中的数据将会丢失，在很多情况下是无法容忍这样的事情的。所以，我们需要将内存中的数据持久化！典型的需要持久化数据的场景如下：</p>
<ul>
<li>将Redis作为数据库使用；</li>
<li>将Redis作为缓存服务器使用，但是缓存miss后会对性能造成很大影响，所有缓存同时失效时会造成服务雪崩，无法响应。</li>
</ul>]]>
    
    </summary>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/tags/Redis/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/categories/Redis/"/>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/categories/Redis/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ZooKeeper使用场景]]></title>
    <link href="http://fudawei.github.io/2015/10/10/ZooKeeper%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://fudawei.github.io/2015/10/10/ZooKeeper使用场景/</id>
    <published>2015-10-10T04:53:14.000Z</published>
    <updated>2015-12-30T05:33:54.978Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>ZooKeeper是一个高可用的分布式数据管理与系统协调框架。基于对Paxos算法的实现，使该框架保证了分布式环境中数据的强一致性，也正是基于这样的特性，使得ZooKeeper解决很多分布式问题。网上对ZK的应用场景也有不少介绍，本文将结合作者身边的项目例子，系统地对ZK的应用场景进行一个分门归类的介绍。</p>
<p>值得注意的是，ZK并非天生就是为这些应用场景设计的，都是后来众多开发者根据其框架的特性，利用其提供的一系列API接口（或者称为原语集），摸索出来的典型使用方法。因此，也非常欢迎读者分享你在ZK使用上的奇技淫巧。<br><a id="more"></a></p>
<h1 id="ZooKeeper应用场景">ZooKeeper应用场景</h1><h2 id="数据发布与订阅（配置中心）">数据发布与订阅（配置中心）</h2><p>发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。<br>应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。<br>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在ZK的一些指定节点，供各个客户端订阅使用。分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用来分配收集任务单元，因此需要在ZK上创建一个以应用名作为path的节点P，并将这个应用的所有机器ip，以子节点的形式注册到节点P上，这样一来就能够实现机器变动的时候，能够实时通知到收集器调整任务分配。<br>系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息的发问。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入ZK之后，就不用自己实现一套方案了，只要将这些信息存放到指定的ZK节点上即可。<br><strong>注意：在上面提到的应用场景中，有个默认前提是：数据量很小，但是数据更新可能会比较快的场景。</strong></p>
<h2 id="负载均衡">负载均衡</h2><p>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。<br>消息中间件中发布者和订阅者的负载均衡，linkedin开源的KafkaMQ和阿里开源的 metaq都是通过zookeeper来做到生产者、消费者的负载均衡。这里以metaq为例讲下： </p>
<h3 id="生产者负载均衡">生产者负载均衡</h3><p>metaq发送消息的时候，生产者在发送消息的时候必须选择一台broker上的一个分区来发送消息，因此metaq在运行过程中，会把所有broker和对应的分区信息全部注册到ZK指定节点上，默认的策略是一个依次轮询的过程，生产者在通过ZK获取分区列表之后，会按照brokerId和partition的顺序排列组织成一个有序的分区列表，发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息。</p>
<h3 id="消费负载均衡：">消费负载均衡：</h3><p>在消费过程中，一个消费者会消费一个或多个分区中的消息，但是一个分区只会由一个消费者来消费。MetaQ的消费策略是：</p>
<ul>
<li>每个分区针对同一个group只挂载一个消费者。</li>
<li>如果同一个group的消费者数目大于分区数目，则多出来的消费者将不参与消费。</li>
<li>如果同一个group的消费者数目小于分区数目，则有部分消费者需要额外承担消费任务。</li>
<li>在某个消费者故障或者重启等情况下，其他消费者会感知到这一变化（通过 zookeeper watch消费者列表），然后重新进行负载均衡，保证所有的分区都有消费者进行消费。</li>
</ul>
<h2 id="命名服务(Naming_Service)">命名服务(Naming Service)</h2><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。<br>阿里巴巴集团开源的分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表， 点击这里查看Dubbo开源项目。在Dubbo实现中：</p>
<blockquote>
<p>服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。<br>服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。<br>注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。<br>另外，Dubbo还有针对服务粒度的监控，方法是订阅/dubbo/${serviceName}目录下所有提供者和消费者的信息。</p>
</blockquote>
<h2 id="分布式通知/协调">分布式通知/协调</h2><p>ZooKeeper中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理<br>另一种心跳检测机制：检测系统和被检测系统之间并不直接关联起来，而是通过zk上某个节点关联，大大减少系统耦合。<br>另一种系统调度模式：某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了ZK上某些节点的状态，而ZK就把这些变化通知给他们注册Watcher的客户端，即推送系统，于是，作出相应的推送任务。<br>另一种工作汇报模式：一些类似于任务分发系统，子任务启动后，到zk来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。<br>总之，使用zookeeper来进行分布式通知和协调能够大大降低系统之间的耦合</p>
<h2 id="集群管理">集群管理</h2><p>集群机器监控通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：</p>
<ul>
<li>集群中机器有变动的时候，牵连修改的东西比较多。</li>
<li>有一定的延时。</li>
</ul>
<p>利用ZooKeeper的两个特性，就可以实时另一种集群机器存活性监控系统：</p>
<blockquote>
<p>客户端在节点x上注册一个Watcher，那么如果x的子节点变化了，会通知该客户端。<br>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。<br>例如，监控系统在 /clusterServers 节点上注册一个Watcher，以后每动态加机器，那么就往 /clusterServers 下创建一个 EPHEMERAL类型的节点：/clusterServers/{hostname}. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。</p>
</blockquote>
<h2 id="Master选举">Master选举</h2><p>Master选举是zookeeper中最为经典的应用场景了。在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。</p>
<p>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。</p>
<p>另外，这种场景演化一下，就是动态Master选举。这就要用到?EPHEMERAL_SEQUENTIAL类型节点的特性了。</p>
<p>上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，就是允许所有请求都能够创建成功，但是得有个创建顺序，于是所有的请求最终在ZK上创建结果的一种可能情况是这样： /currentMaster/{sessionId}-1 ,?/currentMaster/{sessionId}-2 ,?/currentMaster/{sessionId}-3 ….. 每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的节点会马上小时，那么之后最小的那个机器就是Master了。</p>
<p>在搜索系统中，如果集群中每个机器都生成一份全量索引，不仅耗时，而且不能保证彼此之间索引数据一致。因此让集群中的Master来进行全量索引的生成，然后同步到集群中其它机器。另外，Master选举的容灾措施是，可以随时进行手动指定master，就是说应用在zk在无法获取master信息时，可以通过比如http方式，向一个地方获取master。<br>在Hbase中，也是使用ZooKeeper来实现动态HMaster的选举。在Hbase实现中，会在ZK上存储一些ROOT表的地址和HMaster的地址，HRegionServer也会把自己以临时节点（Ephemeral）的方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的存活状态，同时，一旦HMaster出现问题，会重新选举出一个HMaster来运行，从而避免了HMaster的单点问题。</p>
<h2 id="分布式锁">分布式锁</h2><p>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是 保持独占，另一个是 控制时序。<br>所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。<br>控制时序，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
<h2 id="分布式队列">分布式队列</h2><p>队列方面，简单地讲有两种，一种是常规的先进先出队列，另一种是要等到队列成员聚齐之后的才统一按序执行。对于第一种先进先出队列，和分布式锁服务中的控制时序场景基本原理一致，这里不再赘述。<br>第二种队列其实是在FIFO队列的基础上作了一个增强。通常可以在 /queue 这个znode下预先建立一个/queue/num 节点，并且赋值为n（或者直接给/queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。</p>
<h1 id="声明">声明</h1><p>本文非原创，原文链接：<a href="http://itindex.net/detail/53886-zookeeper" target="_blank" rel="external">http://itindex.net/detail/53886-zookeeper</a>，尊重原创，转载请注明出处。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>ZooKeeper是一个高可用的分布式数据管理与系统协调框架。基于对Paxos算法的实现，使该框架保证了分布式环境中数据的强一致性，也正是基于这样的特性，使得ZooKeeper解决很多分布式问题。网上对ZK的应用场景也有不少介绍，本文将结合作者身边的项目例子，系统地对ZK的应用场景进行一个分门归类的介绍。</p>
<p>值得注意的是，ZK并非天生就是为这些应用场景设计的，都是后来众多开发者根据其框架的特性，利用其提供的一系列API接口（或者称为原语集），摸索出来的典型使用方法。因此，也非常欢迎读者分享你在ZK使用上的奇技淫巧。<br>]]>
    
    </summary>
    
      <category term="ZooKeeper" scheme="http://fudawei.github.io/tags/ZooKeeper/"/>
    
      <category term="ZooKeeper" scheme="http://fudawei.github.io/categories/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis过期机制介绍]]></title>
    <link href="http://fudawei.github.io/2015/09/30/Redis%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fudawei.github.io/2015/09/30/Redis过期机制介绍/</id>
    <published>2015-09-30T03:38:17.000Z</published>
    <updated>2015-12-30T06:02:16.176Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>在实际开发过程中经常会遇到一些有时效性数据，比如限时优惠活动，缓存或者验证码之类的。过了一段时间就需要删除这些数据。在关系型数据库中一般都要增加一个字段记录数据的到期时间，然后周期性地检查过期数据然后删除。Redis本身就对键过期提供了很好的支持。</p>
<a id="more"></a>
<h1 id="Redis过期机制">Redis过期机制</h1><p>在Redis中可以使用<strong>EXPIRE</strong>命令设置一个键的存活时间(ttl: time to live)，过了这段时间，该键就会自动被删除，EXPIRE命令的使用方法如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key <span class="function"><span class="title">ttl</span><span class="params">(单位秒)</span></span></span><br></pre></td></tr></table></figure>
<p>命令返回1表示设置ttl成功，返回0表示键不存在或者设置失败。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> session <span class="number">100</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXPIRE session <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get session</span><br><span class="line"><span class="string">"100"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get session</span><br><span class="line"><span class="string">"100"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">get <span class="title">session</span></span><br><span class="line"><span class="params">(nil)</span></span><br><span class="line">127.0.0.1:6379&gt;</span></span><br></pre></td></tr></table></figure>
<p>上例可见，先设置session的值为100，然后设置他的ttl为5s，之后连续几次使用get命令获取session，5s之后将获取不到session，因为ttl时间已到，session被删除。</p>
<p>如果想知道一个键还有多长时间被删除，则可以使用<strong>TTL</strong>命令查看，使用方法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">TTL</span> key</span><br></pre></td></tr></table></figure>
<p>返回值是键的剩余时间，单位秒。</p>
<p>比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">set</span> <span class="tag">session</span> 100</span><br><span class="line"><span class="tag">OK</span></span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">EXPIRE</span> <span class="tag">session</span> 10</span><br><span class="line">(<span class="tag">integer</span>) 1</span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">TTL</span> <span class="tag">session</span></span><br><span class="line">(<span class="tag">integer</span>) 7</span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">TTL</span> <span class="tag">session</span></span><br><span class="line">(<span class="tag">integer</span>) 5</span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">TTL</span> <span class="tag">session</span></span><br><span class="line">(<span class="tag">integer</span>) 2</span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">TTL</span> <span class="tag">session</span></span><br><span class="line">(<span class="tag">integer</span>) 0</span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">TTL</span> <span class="tag">session</span></span><br><span class="line">(<span class="tag">integer</span>) <span class="tag">-2</span></span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">TTL</span> <span class="tag">session</span></span><br><span class="line">(<span class="tag">integer</span>) <span class="tag">-2</span></span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可见，TTL的返回值会随着时间的流逝慢慢减少，10s之后键会被删除，键不存在时TTL会返回-2，<strong>当没有为键设置过期时间时，使用TTL获取键的剩余时间将会返回-1</strong>，比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> url http:<span class="comment">//fudawei.github.io</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">ttl <span class="title">url</span></span><br><span class="line"><span class="params">(integer)</span> -1</span><br><span class="line">127.0.0.1:6379&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果想取消某个键的过期时间，可以使用<strong>PERSIST</strong>命令，用法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">PERSIST</span> key</span><br></pre></td></tr></table></figure>
<p>清除成功返回1，失败返回0.</p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">set</span> <span class="tag">title</span> 飞鸟</span><br><span class="line"><span class="tag">OK</span></span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">EXPIRE</span> <span class="tag">title</span> 100</span><br><span class="line">(<span class="tag">integer</span>) 1</span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">ttl</span> <span class="tag">title</span></span><br><span class="line">(<span class="tag">integer</span>) 97</span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">PERSIST</span> <span class="tag">title</span></span><br><span class="line">(<span class="tag">integer</span>) 1</span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt; <span class="tag">ttl</span> <span class="tag">title</span></span><br><span class="line">(<span class="tag">integer</span>) <span class="tag">-1</span></span><br><span class="line">127<span class="class">.0</span><span class="class">.0</span><span class="class">.1</span><span class="pseudo">:6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>除了PERSIST命令会清除键的过期时间之外，SET,GETSET命令也能清除键的过期时间，但是只对键进行操作的命令（比如INCR,LPUSH等等）不会清除键的过期时间。</p>
<p><strong>EXPIRE命令的单位是秒，如果想要更精确的过期时间，则可以使用PEXPIRE命令，该命令的单位是毫秒，相应地可以使用PTTL看剩余时间。</strong></p>
<p><strong>如果<a href="http://fudawei.github.io/2015/09/30/Redis%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/">WATCH</a>命令监控了一个具有过期时间的键，如果监控期间这个键过期被自动删除，WATCH并不认为该键被改变</strong></p>
<h1 id="Redis过期机制的用途">Redis过期机制的用途</h1><p>有了过期机制就能实现很多跟时间相关的功能了，比如访问频率限制，作为缓存等等，具体细节就不展开了，有疑问的可以留言。</p>
<h1 id="声明">声明</h1><p>本文原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/30/Redis过期机制介绍/">http://fudawei.github.io/2015/09/30/Redis过期机制介绍/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>在实际开发过程中经常会遇到一些有时效性数据，比如限时优惠活动，缓存或者验证码之类的。过了一段时间就需要删除这些数据。在关系型数据库中一般都要增加一个字段记录数据的到期时间，然后周期性地检查过期数据然后删除。Redis本身就对键过期提供了很好的支持。</p>]]>
    
    </summary>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/tags/Redis/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/categories/Redis/"/>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/categories/Redis/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis事务介绍]]></title>
    <link href="http://fudawei.github.io/2015/09/30/Redis%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fudawei.github.io/2015/09/30/Redis事务介绍/</id>
    <published>2015-09-29T16:38:48.000Z</published>
    <updated>2015-12-30T06:02:16.180Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>相信学过Mysql等其他数据库的同学对事务这个词都不陌生，事务表示的是一组动作，这组动作要么全部执行，要么全部不执行。为什么会有这样的需求呢？看看下面的场景：</p>
<blockquote>
<ul>
<li>微博是一个弱关系型社交网络，用户之间有关注和被关注两种关系，比如两个用户A和B，如果A关注B，则B的粉丝中就应该有A。关注这个动作需要两个步骤完成：在A的关注者中添加B；在B的粉丝中添加A。 这两个动作要么都执行成功，要么都不执行。否则就可能会出现A关注了B，但是B的粉丝中没有A的不可容忍的情况。</li>
<li>转账汇款，假设现在有两个账户A和B，现在需要将A中的一万块大洋转到B的账户中，这个动作也需要两个步骤完成：从A的账户中划走一万块；在B的账户中增加一万块。这两个动作要么全部执行成功，要么全部不执行，否则自会有人问候你的！！！</li>
</ul>
</blockquote>
<a id="more"></a>
<p>Redis作为一种高效的分布式数据库，同样支持事务。</p>
<h1 id="Redis事务">Redis事务</h1><p>Redis中的事务(transaction)是一组命令的集合。事务同命令一样都是Redis最小的执行单位，一个事务中的命令要么都执行，要么都不执行。Redis事务的实现需要用到<strong> MULTI </strong>和<strong> EXEC </strong>两个命令，事务开始的时候先向Redis服务器发送<strong> MULTI </strong>命令，然后依次发送需要在本次事务中处理的命令，最后再发送<strong> EXEC </strong>命令表示事务命令结束。</p>
<p>举个例子，使用redis-cli连接redis，然后在命令行工具中输入如下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> url http:<span class="comment">//fudawei.github.io</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> title 飞鸟</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> desc java</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get url</span><br><span class="line"><span class="string">"http://fudawei.github.io"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get title</span><br><span class="line"><span class="string">"飞鸟"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get desc</span><br><span class="line"><span class="string">"java"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>从输出中可以看到，当输入MULTI命令后，服务器返回OK表示事务开始成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回”QUEUED”，这表示命令已经被服务器接受并且暂时保存起来，最后输入EXEC命令后，本次事务中的所有命令才会被依次执行，可以看到最后服务器一次性返回了三个OK，这里返回的结果与发送的命令是按顺序一一对应的，这说明这次事务中的命令全都执行成功了。</p>
<p>再举个例子，在命令行工具中输入如下命令：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span> <span class="constant">MULTI</span></span><br><span class="line"><span class="constant">OK</span></span><br><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span> set a a</span><br><span class="line"><span class="constant">QUEUED</span></span><br><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span> sett b b</span><br><span class="line">(error) <span class="constant">ERR</span> unknown command <span class="string">'sett'</span></span><br><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span> set c c</span><br><span class="line"><span class="constant">QUEUED</span></span><br><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span> <span class="constant">EXEC</span></span><br><span class="line">(error) <span class="constant">EXECABORT</span> <span class="constant">Transaction</span> discarded because of previous errors.</span><br><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span> get a</span><br><span class="line">(<span class="keyword">nil</span>)</span><br><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span> get b</span><br><span class="line">(<span class="keyword">nil</span>)</span><br><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span> get c</span><br><span class="line">(<span class="keyword">nil</span>)</span><br><span class="line"><span class="prompt">127.0.0.1:6379&gt;</span></span><br></pre></td></tr></table></figure>
<p>和前面的例子一样，先输入MULTI最后输入EXEC表示中间的命令属于一个事务，不同的是中间输入的命令有一个错误(set写成了sett)，这样因为有一个错误的命令导致事务中的其他命令都不执行了(通过后续的get命令可以验证)，可见事务中的所有命令式同呼吸共命运的。</p>
<p>如果客户端在发送EXEC命令之前断线了，则服务器会清空事务队列，事务中的所有命令都不会被执行。而一旦客户端发送了EXEC命令之后，事务中的所有命令都会被执行，即使此后客户端断线也没关系，因为服务器已经保存了事务中的所有命令。</p>
<p>除了保证事务中的所有命令要么全执行要么全不执行外，Redis的事务还能保证一个事务中的命令依次执行而不会被其他命令插入。试想一个客户端A需要执行几条命令，同时客户端B发送了几条命令，如果不使用事务，则客户端B的命令有可能会插入到客户端A的几条命令中，如果想避免这种情况发生，也可以使用事务。</p>
<h1 id="Redis事务错误处理">Redis事务错误处理</h1><p>如果一个事务中的某个命令执行出错，Redis会怎样处理呢？要回答这个问题，首先要搞清楚是什么原因导致命令执行出错：</p>
<ol>
<li><p><strong>语法错误</strong> 就像上面的例子一样，语法错误表示命令不存在或者参数错误<br>这种情况需要区分Redis的版本，Redis 2.6.5之前的版本会忽略错误的命令，执行其他正确的命令，2.6.5之后的版本会忽略这个事务中的所有命令，都不执行，就比如上面的例子(使用的Redis版本是2.8的)</p>
</li>
<li><p><strong>运行错误</strong> 运行错误表示命令在执行过程中出现错误，比如用GET命令获取一个散列表类型的键值。<br>这种错误在命令执行之前Redis是无法发现的，所以在事务里这样的命令会被Redis接受并执行。如果食物里有一条命令执行错误，其他命令依旧会执行（包括出错之后的命令）。比如下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> key <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD key <span class="number">2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> key <span class="number">3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line"><span class="number">3</span>) OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get key</span><br><span class="line"><span class="string">"3"</span></span><br></pre></td></tr></table></figure>
<p><strong>Redis中的事务并没有关系型数据库中的事务回滚(rollback)功能，因此使用者必须自己收拾剩下的烂摊子。</strong>不过由于Redis不支持事务回滚功能，这也使得Redis的事务简洁快速。</p>
</li>
</ol>
<p>回顾上面两种类型的错误，语法错误完全可以在开发的时候发现并作出处理，另外如果能很好地规划Redis数据的键的使用，也是不会出现命令和键不匹配的问题的。</p>
<h1 id="WATCH命令">WATCH命令</h1><p>从上面的例子我们可以看到，事务中的命令要全部执行完之后才能获取每个命令的结果，但是如果一个事务中的命令B依赖于他上一个命令A的结果的话该怎么办呢？就比如说实现类似Java中的i++的功能，先要获取当前值，才能在当前值的基础上做加一操作。这种场合仅仅使用上面介绍的MULTI和EXEC是不能实现的，因为MULTI和EXEC中的命令是一起执行的，并不能将其中一条命令的执行结果作为另一条命令的执行参数，所以这个时候就需要引进Redis事务家族中的另一成员：<strong>WATCH命令</strong></p>
<p>换个角度思考上面说到的实现i++的方法，可以这样实现：</p>
<blockquote>
<ol>
<li>监控i的值，保证i的值不被修改</li>
<li>获取i的原值</li>
<li>如果过程中i的值没有被修改，则将当前的i值+1，否则不执行</li>
</ol>
</blockquote>
<p>这样就能够避免竞态条件，保证i++能够正确执行。</p>
<p>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，EXEC命令执行完之后被监控的键会自动被UNWATCH）</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> mykey <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; WATCH mykey</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> mykey <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> mykey <span class="number">3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get mykey</span><br><span class="line"><span class="string">"2"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，首先设置mykey的键值为1，然后使用WATCH命令监控mykey，随后更改mykey的值为2，然后进入事务，事务中设置mykey的值为3，然后执行EXEC运行事务中的命令，最后使用get命令查看mykey的值，发现mykey的值还是2，也就是说事务中的命令根本没有执行（因为WATCH监控mykey的过程中，mykey被修改了，所以随后的事务便会被取消）。</p>
<p>有了WATCH命令，我们就可以自己实现i++功能了，伪代码如下：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def incr(<span class="variable">$key</span>):</span><br><span class="line">    WATCH <span class="variable">$key</span></span><br><span class="line">    <span class="variable">$value</span> = GET <span class="variable">$key</span></span><br><span class="line">    <span class="keyword">if</span> not <span class="variable">$value</span></span><br><span class="line">        <span class="variable">$value</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">$value</span> = <span class="variable">$value</span> + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    MULTI</span><br><span class="line">    SET <span class="variable">$key</span> <span class="variable">$value</span></span><br><span class="line">        result = EXEC</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>因为EXEC返回的是多行字符串，使用result[0]表示返回值的第一个字符串。</p>
<p><strong>注意：由于WATCH命令的作用只是当被监控的键被修改后取消之后的事务，并不能保证其他客户端不修改监控的值，所以当EXEC命令执行失败之后需要手动重新执行整个事务。</strong></p>
<p>执行EXEC命令之后会取消监控使用WATCH命令监控的键，如果不想执行事务中的命令，也可以使用UNWATCH命令来取消监控。</p>
<h1 id="声明">声明</h1><p>本文为原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/30/Redis事务介绍/">http://fudawei.github.io/2015/09/30/Redis事务介绍/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>相信学过Mysql等其他数据库的同学对事务这个词都不陌生，事务表示的是一组动作，这组动作要么全部执行，要么全部不执行。为什么会有这样的需求呢？看看下面的场景：</p>
<blockquote>
<ul>
<li>微博是一个弱关系型社交网络，用户之间有关注和被关注两种关系，比如两个用户A和B，如果A关注B，则B的粉丝中就应该有A。关注这个动作需要两个步骤完成：在A的关注者中添加B；在B的粉丝中添加A。 这两个动作要么都执行成功，要么都不执行。否则就可能会出现A关注了B，但是B的粉丝中没有A的不可容忍的情况。</li>
<li>转账汇款，假设现在有两个账户A和B，现在需要将A中的一万块大洋转到B的账户中，这个动作也需要两个步骤完成：从A的账户中划走一万块；在B的账户中增加一万块。这两个动作要么全部执行成功，要么全部不执行，否则自会有人问候你的！！！</li>
</ul>
</blockquote>]]>
    
    </summary>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/tags/Redis/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/categories/Redis/"/>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/categories/Redis/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis五种数据类型介绍]]></title>
    <link href="http://fudawei.github.io/2015/09/29/Redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fudawei.github.io/2015/09/29/Redis五种数据类型介绍/</id>
    <published>2015-09-28T16:19:31.000Z</published>
    <updated>2015-12-30T06:02:16.180Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>Redis的键值可以使用物种数据类型：<strong>字符串，散列表，列表，集合，有序集合</strong>。本文详细介绍这五种数据类型的使用方法。本文命令介绍部分只是列举了基本的命令，至于具体的使用示例，可以参考Redis官方文档：<a href="http://redis.readthedocs.org/en/latest/" target="_blank" rel="external">Redis命令大全</a><br><a id="more"></a></p>
<h1 id="字符串类型">字符串类型</h1><p>字符串是Redis中最基本的数据类型，它能够存储任何类型的字符串，包含二进制数据。可以用于存储邮箱，JSON化的对象，甚至是一张图片，一个字符串允许存储的最大容量为<strong>512MB</strong>。字符串是其他四种类型的基础，与其他几种类型的区别从本质上来说只是组织字符串的方式不同而已。</p>
<h2 id="基本命令">基本命令</h2><h3 id="字符串操作">字符串操作</h3><ol>
<li><strong>SET</strong> 赋值，用法： <code>SET key value</code></li>
<li><strong>GET</strong> 取值，用法： <code>GET key</code></li>
<li><strong>INCR</strong> 递增数字，仅仅对数字类型的键有用，相当于Java的i++运算，用法： <code>INCR key</code></li>
<li><strong>INCRBY</strong> 增加指定的数字，仅仅对数字类型的键有用，相当于Java的i+=3，用法：<code>INCRBY key increment</code>，意思是key自增increment，increment可以为负数，表示减少。</li>
<li><strong>DECR</strong> 递减数字，仅仅对数字类型的键有用，相当于Java的i–，用法：<code>DECR key</code></li>
<li><strong>DECRBY</strong> 减少指定的数字，仅仅对数字类型的键有用，相当于Java的i-=3，用法：<code>DECRBY key decrement</code>，意思是key自减decrement，decrement可以为正数，表示增加。</li>
<li><strong>INCRBYFLOAT</strong> 增加指定浮点数，仅仅对数字类型的键有用，用法：<code>INCRBYFLOAT key increment</code></li>
<li><strong>APPEND</strong> 向尾部追加值，相当于Java中的”hello”.append(“ world”)，用法：<code>APPEND key value</code></li>
<li><strong>STRLEN</strong> 获取字符串长度，用法：<code>STRLEN key</code></li>
<li><strong>MSET</strong> 同时设置多个key的值，用法：<code>MSET key1 value1 [key2 value2 ...]</code></li>
<li><strong>MGET</strong> 同时获取多个key的值，用法：<code>MGET key1 [key2 ...]</code></li>
</ol>
<h3 id="位操作">位操作</h3><ol>
<li><strong>GETBIT</strong> 获取一个键值的二进制位的指定位置的值(0/1)，用法：<code>GETBIT key offset</code></li>
<li><strong>SETBIT</strong> 设置一个键值的二进制位的指定位置的值(0/1)，用法：<code>SETBIT key offset value</code></li>
<li><strong>BITCOUNT</strong> 获取一个键值的一个范围内的二进制表示的1的个数，用法：<code>BITCOUNT key [start end]</code></li>
<li><strong>BITOP</strong> 该命令可以对多个字符串类型键进行位运算，并将结果存储到指定的键中，BITOP支持的运算包含：<strong>OR,AND,XOR,NOT</strong>，用法：<code>BITOP OP desKey key1 key2</code></li>
<li><strong>BITPOS</strong> 获取指定键的第一个位值为0或者1的位置，用法：<code>BITPOS key 0/1 [start， end]</code></li>
</ol>
<h1 id="散列类型">散列类型</h1><p>散列类型相当于Java中的HashMap，他的值是一个字典，保存很多key，value对，每对key，value的值个键都是字符串类型，换句话说，散列类型不能嵌套其他数据类型。一个散列类型键最多可以包含2的32次方-1个字段。</p>
<h2 id="基本命令-1">基本命令</h2><ol>
<li><strong>HSET</strong> 赋值，用法：<code>HSET key field value</code></li>
<li><strong>HMSET</strong> 一次赋值多个字段，用法：<code>HMSET key field1 value1 [field2 values]</code></li>
<li><strong>HGET</strong> 取值，用法：<code>HSET key field</code></li>
<li><strong>HMGET</strong> 一次取多个字段的值，用法：<code>HMSET key field1 [field2]</code></li>
<li><strong>HGETALL</strong> 一次取所有字段的值，用法：<code>HGETALL key</code></li>
<li><strong>HEXISTS</strong> 判断字段是否存在，用法：<code>HEXISTS key field</code></li>
<li><strong>HSETNX</strong> 当字段不存在时赋值，用法：<code>HSETNX key field value</code></li>
<li><strong>HINCRBY</strong> 增加数字，仅对数字类型的值有用，用法：<code>HINCRBY key field increment</code></li>
<li><strong>HDEL</strong> 删除字段，用法：<code>HDEL key field</code></li>
<li><strong>HKEYS</strong> 获取所有字段名，用法：<code>HKEYS key</code></li>
<li><strong>HVALS</strong> 获取所有字段值，用法：<code>HVALS key</code></li>
<li><strong>HLEN</strong> 获取字段数量，用法：<code>HLEN key</code></li>
</ol>
<h1 id="列表类型">列表类型</h1><p>列表类型(list)用于存储一个有序的字符串列表，常用的操作是向队列两端添加元素或者获得列表的某一片段。列表内部使用的是双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度是O(1),获取越接近列表两端的元素的速度越快。但是缺点是使用列表通过索引访问元素的效率太低（需要从端点开始遍历元素）。所以列表的使用场景一般如：朋友圈新鲜事，只关心最新的一些内容。借助列表类型，Redis还可以作为消息队列使用。</p>
<h2 id="基本命令-2">基本命令</h2><ol>
<li><strong>LPUSH</strong> 向列表左端添加元素，用法：<code>LPUSH key value</code></li>
<li><strong>RPUSH</strong> 向列表右端添加元素，用法：<code>RPUSH key value</code></li>
<li><strong>LPOP</strong> 从列表左端弹出元素，用法：<code>LPOP key</code></li>
<li><strong>RPOP</strong> 从列表右端弹出元素，用法：<code>RPOP key</code></li>
<li><strong>LLEN</strong> 获取列表中元素个数，用法：<code>LLEN key</code></li>
<li><strong>LRANGE</strong> 获取列表中某一片段的元素，用法：<code>LRANGE key start stop</code>，index从0开始，-1表示最后一个元素</li>
<li><strong>LREM</strong> 删除列表中指定的值，用法：<code>LREM key count value</code>，删除列表中前count个值为value的元素，当count&gt;0时从左边开始数，count&lt;0时从右边开始数，count=0时会删除所有值为value的元素</li>
<li><strong>LINDEX</strong> 获取指定索引的元素值，用法：<code>LINDEX key index</code></li>
<li><strong>LSET</strong> 设置指定索引的元素值，用法：<code>LSET key index value</code></li>
<li><strong>LTRIM</strong> 只保留列表指定片段，用法：<code>LTRIM key start stop</code>，包含start和stop</li>
<li><strong>LINSERT</strong> 像列表中插入元素，用法：<code>LINSERT key BEFORE|AFTER privot value</code>，从左边开始寻找值为privot的第一个元素，然后根据第二个参数是BEFORE还是AFTER决定在该元素的前面还是后面插入value</li>
<li><strong>RPOPLPUSH</strong> 将元素从一个列表转义到另一个列表，用法：<code>RPOPLPUSH source destination</code></li>
</ol>
<h1 id="集合类型">集合类型</h1><p>集合在概念在高中课本就学过，集合中每个元素都是不同的，集合中的元素个数最多为2的32次方-1个，集合中的元素师没有顺序的。</p>
<h2 id="基本命令-3">基本命令</h2><ol>
<li><strong>SADD</strong> 添加元素，用法：<code>SADD key value1 [value2 value3 ...]</code></li>
<li><strong>SREM</strong> 删除元素，用法：<code>SREM key value2 [value2 value3 ...]</code></li>
<li><strong>SMEMBERS</strong> 获得集合中所有元素，用法：<code>SMEMBERS key</code></li>
<li><strong>SISMEMBER</strong> 判断元素是否在集合中，用法：<code>SISMEMBER key value</code></li>
<li><strong>SDIFF</strong> 对集合做差集运算，用法：<code>SDIFF key1 key2 [key3 ...]</code>，先计算key1和key2的差集，然后再用结果与key3做差集</li>
<li><strong>SINTER</strong> 对集合做交集运算，用法：<code>SINTER key1 key2 [key3 ...]</code></li>
<li><strong>SUNION</strong> 对集合做并集运算，用法：<code>SUNION key1 key2 [key3 ...]</code></li>
<li><strong>SCARD</strong> 获得集合中元素的个数，用法：<code>SCARD key</code></li>
<li><strong>SDIFFSTORE</strong> 对集合做差集并将结果存储，用法：<code>SDIFFSTORE destination key1 key2 [key3 ...]</code></li>
<li><strong>SINTERSTORE</strong> 对集合做交集运算并将结果存储，用法：<code>SINTERSTORE destination key1 key2 [key3 ...]</code></li>
<li><strong>SUNIONSTORE</strong> 对集合做并集运算并将结果存储，用法：<code>SUNIONSTORE destination key1 key2 [key3 ...]</code></li>
<li><strong>SRANDMEMBER</strong> 随机获取集合中的元素，用法：<code>SRANDMEMBER key [count]</code>，当count&gt;0时，会随机中集合中获取count个不重复的元素，当count&lt;0时，随机中集合中获取|count|和可能重复的元素。</li>
<li><strong>SPOP</strong> 从集合中随机弹出一个元素，用法：<code>SPOP key</code></li>
</ol>
<h1 id="有序集合类型">有序集合类型</h1><p>有序集合类型与集合类型的区别就是他是有序的。有序集合是在集合的基础上为每一个元素关联一个分数，这就让有序集合不仅支持插入，删除，判断元素是否存在等操作外，还支持获取分数最高/最低的前N个元素。有序集合中的每个元素是不同的，但是分数却可以相同。有序集合使用散列表和跳跃表实现，即使读取位于中间部分的数据也很快，时间复杂度为O(log(N))，有序集合比列表更费内存。</p>
<h2 id="基本命令-4">基本命令</h2><ol>
<li><strong>ZADD</strong> 添加元素，用法：<code>ZADD key score1 value1 [score2 value2 score3 value3 ...]</code></li>
<li><strong>ZSCORE</strong> 获取元素的分数，用法：<code>ZSCORE key value</code></li>
<li><strong>ZRANGE</strong> 获取排名在某个范围的元素，用法：<code>ZRANGE key start stop [WITHSCORE]</code>，按照元素从小到大的顺序排序，从0开始编号，包含start和stop对应的元素，WITHSCORE选项表示是否返回元素分数</li>
<li><strong>ZREVRANGE</strong> 获取排名在某个范围的元素，用法：<code>ZREVRANGE key start stop [WITHSCORE]</code>，和上一个命令用法一样，只是这个倒序排序的。</li>
<li><strong>ZRANGEBYSCORE</strong> 获取指定分数范围内的元素，用法：<code>ZRANGEBYSCORE key min max</code>，包含min和max，<code>(min</code>表示不包含min，<code>(max</code>表示不包含max，<code>+inf</code>表示无穷大</li>
<li><strong>ZINCRBY</strong> 增加某个元素的分数，用法：<code>ZINCRBY key increment value</code></li>
<li><strong>ZCARD</strong> 获取集合中元素的个数，用法：<code>ZCARD key</code></li>
<li><strong>ZCOUNT</strong> 获取指定分数范围内的元素个数，用法：<code>ZCOUNT key min max</code>，min和max的用法和5中的一样</li>
<li><strong>ZREM</strong> 删除一个或多个元素，用法：<code>ZREM key value1 [value2 ...]</code></li>
<li><strong>ZREMRANGEBYRANK</strong> 按照排名范围删除元素，用法：<code>ZREMRANGEBYRANK key start stop</code></li>
<li><strong>ZREMRANGEBYSCORE</strong> 按照分数范围删除元素，用法：<code>ZREMRANGEBYSCORE key min max</code>，min和max的用法和4中的一样</li>
<li><strong>ZRANK</strong> 获取正序排序的元素的排名，用法：<code>ZRANK key value</code></li>
<li><strong>ZREVRANK</strong> 获取逆序排序的元素的排名，用法：<code>ZREVRANK key value</code></li>
<li><strong>ZINTERSTORE</strong> 计算有序集合的交集并存储结果，用法：<code>ZINTERSTORE destination numbers key1 key2 [key3 key4 ...] WEIGHTS weight1 weight2 [weight3 weight4 ...] AGGREGATE SUM | MIN | MAX</code>，numbers表示参加运算的集合个数，weight表示权重，aggregate表示结果取值</li>
<li><strong>ZUNIONSTORE</strong> 计算有序几个的并集并存储结果，用法和14一样，不再赘述。</li>
</ol>
<h1 id="声明">声明</h1><p>本文为原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/29/Redis五种数据类型介绍/">http://fudawei.github.io/2015/09/29/Redis五种数据类型介绍/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>Redis的键值可以使用物种数据类型：<strong>字符串，散列表，列表，集合，有序集合</strong>。本文详细介绍这五种数据类型的使用方法。本文命令介绍部分只是列举了基本的命令，至于具体的使用示例，可以参考Redis官方文档：<a href="http://redis.readthedocs.org/en/latest/">Redis命令大全</a><br>]]>
    
    </summary>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/tags/Redis/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/categories/Redis/"/>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/categories/Redis/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis 3.0新特性]]></title>
    <link href="http://fudawei.github.io/2015/09/28/Redis-3-0%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://fudawei.github.io/2015/09/28/Redis-3-0新特性/</id>
    <published>2015-09-28T04:42:55.000Z</published>
    <updated>2015-12-30T05:33:54.982Z</updated>
    <content type="html"><![CDATA[<h1 id="Redis_3-0改进">Redis 3.0改进</h1><p>Redis 3.0.0 正式版终于到来了，与 RC6 版本比较，该版本改进包括：</p>
<ul>
<li>修复了无磁盘的复制问题 (Oran Agra)</li>
<li>在角色变化后对 BLPOP 复制进行测试 (Salvatore Sanfilippo)</li>
<li>prepareClientToWrite() 错误处理方法的改进 (Salvatore Sanfilippo)</li>
<li>移除 dict.c 中不再使用的函数(Salvatore Sanfilippo)<a id="more"></a>
</li>
</ul>
<h1 id="Redis_3-0新特性">Redis 3.0新特性</h1><p>Redis 3.0 版本与 2.8 版本比较，主要新特性包括如下几个方面：</p>
<ul>
<li>Redis Cluster —— 一个分布式的 Redis 实现</li>
<li>全新的 “embedded string” 对象编码结果，更少的缓存丢失，在特定的工作负载下速度的大幅提升</li>
<li>AOF child -&gt; parent 最终数据传输最小化延迟，通过在 AOF 重写过程中的  “last write” </li>
<li>大幅提升 LRU 近似算法用于键的擦除</li>
<li>WAIT 命令堵塞等待写操作传输到指定数量的从节点</li>
<li>MIGRATE 连接缓存，大幅提升键移植的速度</li>
<li>MIGARTE 新的参数 COPY 和 REPLACE</li>
<li>CLIENT PAUSE 命令：在指定时间内停止处理客户端请求</li>
<li>BITCOUNT 性能提升</li>
<li>CONFIG SET 接受不同单位的内存值，例如 “CONFIG SET maxmemory 1gb”.</li>
<li>Redis 日志格式小调整用于反应实例的角色 (master/slave) </li>
<li>INCR 性能提升</li>
</ul>
<p>下载地址：<a href="http://download.redis.io/releases/redis-3.0.0.tar.gz" target="_blank" rel="external">http://download.redis.io/releases/redis-3.0.0.tar.gz</a></p>
<h1 id="参考">参考</h1><ol>
<li><a href="http://www.oschina.net/news/61115/redis-3-0-final" target="_blank" rel="external">http://www.oschina.net/news/61115/redis-3-0-final</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Redis_3-0改进">Redis 3.0改进</h1><p>Redis 3.0.0 正式版终于到来了，与 RC6 版本比较，该版本改进包括：</p>
<ul>
<li>修复了无磁盘的复制问题 (Oran Agra)</li>
<li>在角色变化后对 BLPOP 复制进行测试 (Salvatore Sanfilippo)</li>
<li>prepareClientToWrite() 错误处理方法的改进 (Salvatore Sanfilippo)</li>
<li>移除 dict.c 中不再使用的函数(Salvatore Sanfilippo)]]>
    
    </summary>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/tags/Redis/"/>
    
      <category term="Redis" scheme="http://fudawei.github.io/categories/Redis/"/>
    
      <category term="NoSQL" scheme="http://fudawei.github.io/categories/Redis/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shell特殊字符简介]]></title>
    <link href="http://fudawei.github.io/2015/09/23/Shell%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%AE%80%E4%BB%8B/"/>
    <id>http://fudawei.github.io/2015/09/23/Shell特殊字符简介/</id>
    <published>2015-09-22T16:07:02.000Z</published>
    <updated>2015-12-30T06:02:16.184Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>linux shell中有很多特殊的字符，本文简单介绍常用的特殊字符的含义：<br><a id="more"></a></p>
<ul>
<li><strong>$0</strong> 表示当前运行的脚本的名字</li>
<li><strong>$#</strong> 表示当前运行的脚本的参数个数</li>
<li><strong>$*</strong> 表示当前运行的脚本的参数列表，如果有三个参数：a b c，则$*为 “a b c”</li>
<li><strong>$@</strong> 表示当前运行的脚本的参数列表，如果有三个参数：a b c，则$@为 “a” “b” “c”，可以理解为参数数组</li>
<li><strong>$$</strong> 当前运行的脚本的PID</li>
<li><strong>$n</strong> n为一个整数(1 &lt;= n &lt;= 脚本参数个数)，表示当前脚本接收到的第n个参数</li>
<li><strong>$?</strong> 表示目前为止执行的最后一条命令的返回值，返回0表示成功，返回1表示失败</li>
<li><strong>$-</strong> 表示当前shell的设置选项</li>
</ul>
<h1 id="代码演示">代码演示</h1><p>如下是一个简单的脚本test.sh，用于演示上面提到的各种特殊字符的效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"脚本名字:"</span><span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"脚本参数:"</span>$*</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"脚本参数:"</span><span class="variable">$@</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"脚本参数个数:"</span><span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"脚本第一个参数:"</span><span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"脚本第二个参数:"</span><span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"本脚本运行PID:"</span>$$</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前shell选项:"</span>$-</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test text"</span> | grep <span class="string">"test"</span> <span class="number">1</span>&gt;/dev/null</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"上一条命令执行结果:"</span>$?</span><br></pre></td></tr></table></figure>
<p>使用如下命令运行上面的脚本：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@Mac~/shell]$ ./test<span class="class">.sh</span> <span class="tag">a</span> <span class="tag">b</span> c</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<blockquote>
<p>脚本名字:./test.sh<br>脚本参数:a b c<br>脚本参数:a b c<br>脚本参数个数:3<br>脚本第一个参数:a<br>脚本第二个参数:b<br>本脚本运行PID:37073<br>当前shell选项:hB<br>上一条命令执行结果:0  </p>
</blockquote>
<h1 id="声明">声明</h1><p>本文原创，转载请注明出处，本文链接<a href="http://fudawei.github.io/2015/09/23/Shell特殊字符简介">http://fudawei.github.io/2015/09/23/Shell特殊字符简介</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>linux shell中有很多特殊的字符，本文简单介绍常用的特殊字符的含义：<br>]]>
    
    </summary>
    
      <category term="linux shell" scheme="http://fudawei.github.io/tags/linux-shell/"/>
    
      <category term="linux shell" scheme="http://fudawei.github.io/categories/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sed命令详解]]></title>
    <link href="http://fudawei.github.io/2015/09/21/sed%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://fudawei.github.io/2015/09/21/sed命令详解/</id>
    <published>2015-09-21T15:16:16.000Z</published>
    <updated>2015-12-30T06:02:16.184Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。</p>
<a id="more"></a>
<h1 id="使用语法">使用语法</h1><p>sed命令的使用规则是这样的：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sed</span> [option] <span class="string">'command'</span> input_file</span><br></pre></td></tr></table></figure>
<p>其中option是可选的，常用的option有如下几种：</p>
<ul>
<li><strong>-n</strong> 使用安静(silent)模式（想不通为什么不是-s）。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来；</li>
<li><strong>-e</strong> 直接在指令列模式上进行 sed 的动作编辑；</li>
<li><strong>-f</strong> 直接将 sed 的动作写在一个文件内， <code>-f filename</code> 则可以执行filename内的sed命令；</li>
<li><strong>-r</strong> 让sed命令支持扩展的正则表达式(默认是基础正则表达式)；</li>
<li><p><strong>-i</strong> 直接修改读取的文件内容，而不是由屏幕输出。</p>
<p>常用的命令有以下几种：</p>
</li>
<li><p><strong>a \：</strong> append即追加字符串， a \的后面跟上字符串s(多行字符串可以用\n分隔)，则会在当前选择的行的后面都加上字符串s；</p>
</li>
<li><strong>c \：</strong> 取代/替换字符串，c \后面跟上字符串s(多行字符串可以用\n分隔)，则会将当前选中的行替换成字符串s；</li>
<li><strong>d：</strong> delete即删除，该命令会将当前选中的行删除；</li>
<li><strong>i \：</strong> insert即插入字符串，i \后面跟上字符串s(多行字符串可以用\n分隔)，则会在当前选中的行的前面都插入字符串s；</li>
<li><strong>p：</strong> print即打印，该命令会打印当前选择的行到屏幕上；</li>
<li><strong>s：</strong> 替换，通常s命令的用法是这样的：<code>1，2s/old/new/g</code>，将old字符串替换成new字符串</li>
</ul>
<h1 id="命令示例">命令示例</h1><p>假设有一个本地文件test.txt，文件内容如下：</p>
<blockquote>
<p>[qifuguang@winwill~]$ cat test.txt<br>this is first line<br>this is second line<br>this is third line<br>this is fourth line<br>this fifth line<br>happy everyday<br>end  </p>
</blockquote>
<p>本节将使用该文件详细演示每一个命令的用法。</p>
<h2 id="a命令">a命令</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed <span class="string">'1a \add one'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> is first <span class="built_in">line</span></span><br><span class="line"><span class="built_in">add</span> one</span><br><span class="line"><span class="keyword">this</span> is <span class="built_in">second</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is third <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fourth <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fifth <span class="built_in">line</span></span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>本例命令部分中的1表示第一行，同样的第二行写成2，第一行到第三行写成<code>1,3</code>，用<code>$</code>表示最后一行，比如<code>2,$</code>表示第二行到最后一行中间所有的行(包含第二行和最后一行)。<br>本例的作用是在第一行之后增加字符串”add one”，从输出可以看到具体效果。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed '1,$a \<span class="built_ins">add</span> one' test.txt</span><br><span class="line">this is first line</span><br><span class="line"><span class="built_in">add</span> <span class="bash">one</span><br><span class="line"></span>this is second line</span><br><span class="line"><span class="built_in">add</span> <span class="bash">one</span><br><span class="line"></span>this is third line</span><br><span class="line"><span class="built_in">add</span> <span class="bash">one</span><br><span class="line"></span>this is fourth line</span><br><span class="line"><span class="built_in">add</span> <span class="bash">one</span><br><span class="line"></span>this is fifth line</span><br><span class="line"><span class="built_in">add</span> <span class="bash">one</span><br><span class="line"></span>happy everyday</span><br><span class="line"><span class="built_in">add</span> <span class="bash">one</span><br><span class="line"></span>end</span><br><span class="line"><span class="built_in">add</span> <span class="bash">one</span></span><br></pre></td></tr></table></figure>
<p>本例表示在第一行和最后一行所有的行后面都加上”add one”字符串，从输出可以看到效果。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed <span class="string">'/first/a \add one'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> is first <span class="built_in">line</span></span><br><span class="line"><span class="built_in">add</span> one</span><br><span class="line"><span class="keyword">this</span> is <span class="built_in">second</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is third <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fourth <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fifth <span class="built_in">line</span></span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>本例表示在包含”first”字符串的行的后面加上字符串”add one”，从输出可以看到第一行包含first，所以第一行之后增加了”add one”</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed <span class="string">'/^ha.*day$/a \add one'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> is first <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is <span class="built_in">second</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is third <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fourth <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fifth <span class="built_in">line</span></span><br><span class="line">happy everyday</span><br><span class="line"><span class="built_in">add</span> one</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>本例使用正则表达式匹配行，<code>^ha.*day$</code>表示以ha开头，以day结尾的行，则可以匹配到文件的”happy everyday”这样，所以在该行后面增加了”add one”字符串。</p>
<h2 id="i命令">i命令</h2><p>i命令使用方法和a命令一样的，只不过是在匹配的行的前面插入字符串，所以直接将上面a命令的示例的a替换成i即可，在此就不啰嗦了。</p>
<h2 id="c命令">c命令</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed <span class="string">'$c \add one'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> is first <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is <span class="built_in">second</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is third <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fourth <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is     fifth <span class="built_in">line</span></span><br><span class="line">happy everyday</span><br><span class="line"><span class="built_in">add</span> one</span><br></pre></td></tr></table></figure>
<p>本例表示将最后一行替换成字符串”add one”，从输出可以看到效果。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed <span class="string">'4,$c \add one'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> is first <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is <span class="built_in">second</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is third <span class="built_in">line</span></span><br><span class="line"><span class="built_in">add</span> one</span><br></pre></td></tr></table></figure>
<p>本例将第四行到最后一行的内容替换成字符串”add one”。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed <span class="string">'/^ha.*day$/c \replace line'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> is first <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is <span class="built_in">second</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is third <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fourth <span class="built_in">line</span></span><br><span class="line"><span class="keyword">this</span> is fifth <span class="built_in">line</span></span><br><span class="line">replace <span class="built_in">line</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>本例将以ha开头，以day结尾的行替换成”replace line”。</p>
<h2 id="d命令">d命令</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed '/^ha.*<span class="property">day</span>$/d' test.txt</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">first</span> line</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">second</span> line</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">third</span> line</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">fourth</span> line</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">fifth</span> line</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>本例删除以ha开头，以day结尾的行。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang<span class="property">@winwill</span>~]$ sed <span class="string">'4,$d'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> first line</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> second line</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> third line</span><br></pre></td></tr></table></figure>
<p>本例删除第四行到最后一行中的内容。</p>
<h2 id="p命令">p命令</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang<span class="property">@winwill</span>~]$ sed -n <span class="string">'4,$p'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> fourth line</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> fifth line</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>本例在屏幕上打印第四行到最后一行的内容，p命令一般和-n选项一起使用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang<span class="variable">@winwill</span>~]<span class="variable">$ </span>sed -n <span class="string">'/^ha.*day$/p'</span> test.txt</span><br><span class="line">happy everyday</span><br></pre></td></tr></table></figure>
<p>本例打印以ha开始，以day结尾的行。</p>
<h2 id="s命令">s命令</h2><p>实际运用中s命令式最常使用到的。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed 's/line/<span class="type">text</span>/g' test.txt</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">first</span> <span class="type">text</span></span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">second</span> <span class="type">text</span></span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">third</span> <span class="type">text</span></span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">fourth</span> <span class="type">text</span></span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">fifth</span> <span class="type">text</span></span><br><span class="line">happy everyday</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>本例将文件中的所有line替换成text，最后的g是global的意思，也就是全局替换，如果不加g，则只会替换本行的第一个line。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed '/^ha.*<span class="property">day</span>$/s/happy/very happy/g' test.txt</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">first</span> line</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">second</span> line</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">third</span> line</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">fourth</span> line</span><br><span class="line">this <span class="keyword">is</span> <span class="keyword">fifth</span> line</span><br><span class="line">very happy everyday</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>本例首先匹配以ha开始，以day结尾的行，本例中匹配到的行是”happy everyday”这样，然后再将该行中的happy替换成very happy。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang<span class="property">@winwill</span>~]$ sed <span class="string">'s/\(.*\)line$/\1/g'</span> test.txt</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> first</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> second</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> third</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> fourth</span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> fifth</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这个例子有点复杂，先分解一下。首先s命令的模式是<code>s/old/new/g</code>这样的，所以本例的old部分即<code>\(.*\)line$</code>,sed命令中使用<code>\(\)</code>包裹的内容表示正则表达式的第n部分，序号从1开始计算，本例中只有一个<code>\(\)</code>所以<code>\(.*\)</code>表示正则表达式的第一部分，这部分匹配任意字符串，所以<code>\(.*\)line$</code>匹配的就是以line结尾的任何行。然后将匹配到的行替换成正则表达式的第一部分（本例中相当于删除line部分），使用<code>\1</code>表示匹配到的第一部分，同样<code>\2</code>表示第二部分，<code>\3</code>表示第三部分，可以依次这样引用。比如下面的例子：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qifuguang@winwill~]$ sed 's/\(.*\)<span class="keyword">is</span>\(.*\)line/\<span class="number">1</span>\<span class="number">2</span>/g' test.txt</span><br><span class="line">this  <span class="keyword">first</span></span><br><span class="line">this  <span class="keyword">second</span></span><br><span class="line">this  <span class="keyword">third</span></span><br><span class="line">this  <span class="keyword">fourth</span></span><br><span class="line">this  <span class="keyword">fifth</span></span><br><span class="line">happy everyday</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>正则表达式中<code>is</code>两边的部分可以用<code>\1</code>和<code>\2</code>表示，该例子的作用其实就是删除中间部分的is。</p>
<h1 id="声明">声明</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/21/sed命令详解/">http://fudawei.github.io/2015/09/21/sed命令详解/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。</p>]]>
    
    </summary>
    
      <category term="linux shell" scheme="http://fudawei.github.io/tags/linux-shell/"/>
    
      <category term="linux shell" scheme="http://fudawei.github.io/categories/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IntelliJ远程调试教程]]></title>
    <link href="http://fudawei.github.io/2015/09/18/IntelliJ%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B/"/>
    <id>http://fudawei.github.io/2015/09/18/IntelliJ远程调试教程/</id>
    <published>2015-09-18T08:08:56.000Z</published>
    <updated>2015-12-30T06:02:16.176Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>对于分布式系统的调试不知道大家有什么好的方法。对于我来说，在知道远程调试这个方法之前就是在代码中打各种log，然后重新部署，上线，调试，这样比较费时。今天咱们来了解了解Java远程调试这个牛逼的功能，本文以Intellij IDEA为例讲解怎么使用远程调试。以<a href="http://fudawei.github.io/2015/09/11/Thrift%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">Thrift入门教程</a>这篇文章中使用的程序作为例子。这个程序由Thrift服务端和客户端组成。描述一下远程调试需要解决的问题：</p>
<a id="more"></a>
<blockquote>
<p>服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（前提是本地的代码必须和远程服务器运行的代码一致）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态。</p>
</blockquote>
<p>下面按照步骤介绍怎么远程debug。</p>
<h1 id="使用特定JVM参数运行服务端代码">使用特定JVM参数运行服务端代码</h1><p>要让远程服务器运行的代码支持远程调试，则启动的时候必须加上特定的JVM参数，这些参数是：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">Xdebug</span> -<span class="constant">Xrunjdwp</span><span class="symbol">:transport=dt_socket</span>,suspend=n,server=y,address=<span class="variable">$&#123;</span>debug_port&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中的${debug_port}是用户自定义的，为debug端口，本例以5555端口为例。</p>
<h1 id="本地连接远程服务器debug端口">本地连接远程服务器debug端口</h1><p>打开Intellij IDEA，在顶部靠右的地方选择”Edit Configurations…”，进去之后点击+号，选择”Remote”，按照下图的只是填写红框内的内容，其中host为远程代码运行的机器的ip/hostname，port为上一步指定的debug_port，本例是5555<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/create_remote.png" alt=""><br>然后点击Apply，最后点击OK即可</p>
<h1 id="启动debug模式">启动debug模式</h1><p> 现在在上一步选择”Edit Configurations…”的下拉框的位置选择上一步创建的remote的名字，然后点击右边的debug按钮(长的像臭虫那个)，看控制台日志，如果出现类似<strong>“Connected to the target VM, address: ‘xx.xx.xx.xx:5555’, transport: ‘socket’”</strong>的字样，就表示连接成功过了。<br> <img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/start_remote.png" alt=""></p>
<h1 id="设置断点，开始调试">设置断点，开始调试</h1><p>远程debug模式已经开启，现在可以在需要调试的代码中打断点了，比如：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/create_debug_point.png" alt=""><br>如图中所示，如果断点内有√，则表示选取的断点正确。</p>
<p>现在在本地发送一个到远程服务器的请求，看本地控制台的bug界面，划到debugger这个标签，可以看到当前远程服务的内部状态（各种变量）已经全部显示出来了，并且在刚才设置了断点的地方，也显示了该行的变量值。<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/show_debug_result1.png" alt=""><br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/show_debug_result2.png" alt=""></p>
<h1 id="注意事项">注意事项</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/18/IntelliJ远程调试教程">http://fudawei.github.io/2015/09/18/IntelliJ远程调试教程</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>对于分布式系统的调试不知道大家有什么好的方法。对于我来说，在知道远程调试这个方法之前就是在代码中打各种log，然后重新部署，上线，调试，这样比较费时。今天咱们来了解了解Java远程调试这个牛逼的功能，本文以Intellij IDEA为例讲解怎么使用远程调试。以<a href="http://fudawei.github.io/2015/09/11/Thrift%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">Thrift入门教程</a>这篇文章中使用的程序作为例子。这个程序由Thrift服务端和客户端组成。描述一下远程调试需要解决的问题：</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://fudawei.github.io/tags/Java/"/>
    
      <category term="工具" scheme="http://fudawei.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Java" scheme="http://fudawei.github.io/categories/Java/"/>
    
      <category term="工具" scheme="http://fudawei.github.io/categories/Java/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Thrift入门教程]]></title>
    <link href="http://fudawei.github.io/2015/09/11/Thrift%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://fudawei.github.io/2015/09/11/Thrift入门教程/</id>
    <published>2015-09-11T08:42:30.000Z</published>
    <updated>2015-12-30T06:02:16.184Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，支持跨语言，常用的语言比如C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml都支持。Thrift是一个典型的CS（客户端/服务端）结构，客户端和服务端可以使用不同的语言开发。既然客户端和服务端能使用不同的语言开发，那么一定就要有一种中间语言来关联客户端和服务端的语言，没错，这种语言就是IDL（Interface Description Language）。<br><a id="more"></a></p>
<h1 id="Thrift_IDL">Thrift IDL</h1><p>本节介绍Thrift的接口定义语言，Thrift IDL支持的数据类型包含：</p>
<h2 id="基本类型">基本类型</h2><p>thrift不支持无符号类型，因为很多编程语言不存在无符号类型，比如java</p>
<ul>
<li>byte: 有符号字节</li>
<li>i16: 16位有符号整数</li>
<li>i32: 32位有符号整数</li>
<li>i64: 64位有符号整数</li>
<li>double: 64位浮点数</li>
<li>string: 字符串  </li>
</ul>
<h2 id="容器类型">容器类型</h2><p>集合中的元素可以是除了service之外的任何类型，包括exception。</p>
<ul>
<li>list<t>: 一系列由T类型的数据组成的有序列表，元素可以重复</t></li>
<li>set<t>:  一系列由T类型的数据组成的无序集合，元素不可重复</t></li>
<li>map<k, v="">: 一个字典结构，key为K类型，value为V类型，相当于Java中的HMap<k,v>  </k,v></k,></li>
</ul>
<h2 id="结构体(struct)">结构体(struct)</h2><p>就像C语言一样，thrift也支持struct类型，目的就是将一些数据聚合在一起，方便传输管理。struct的定       义形式如下：  </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">struct</span> <span class="tag">People</span> &#123;</span><br><span class="line">     <span class="attribute">1</span>: string name;</span><br><span class="line">     <span class="attribute">2</span>: i32 age;</span><br><span class="line">     <span class="attribute">3</span>: string sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举(enum)">枚举(enum)</h2><p>枚举的定义形式和Java的Enum定义差不多，例如：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    MALE,</span><br><span class="line">    FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常(exception)">异常(exception)</h2><p>thrift支持自定义exception，规则和struct一样，如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">exception</span> <span class="tag">RequestException</span> &#123;</span><br><span class="line">    <span class="attribute">1</span>: i32 code;</span><br><span class="line">    <span class="attribute">2</span>: string reason;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务(service)">服务(service)</h2><p>thrift定义服务相当于Java中创建Interface一样，创建的service经过代码生成命令之后就会生成客户端和服务端的框架代码。定义形式如下：</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloWordService</span> </span>&#123;</span><br><span class="line">     <span class="comment">// service中定义的函数，相当于Java interface中定义的函数</span></span><br><span class="line">     <span class="built_in">string</span> doAction(<span class="number">1</span>: <span class="built_in">string</span> name, <span class="number">2</span>: <span class="built_in">i32</span> age);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型定义">类型定义</h2><p>thrift支持类似C++一样的typedef定义，比如：</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">i32</span> Integer</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">i64</span> Long</span><br></pre></td></tr></table></figure>
<p><strong>注意，末尾没有逗号或者分号</strong></p>
<h2 id="常量(const)">常量(const)</h2><p>thrift也支持常量定义，使用const关键字，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i32 MAX_RETRIES_TIME = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> MY_WEBSITE = <span class="string">"http://fudawei.github.io"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>末尾的分号是可选的，可有可无，并且支持16进制赋值</strong></p>
<h2 id="命名空间">命名空间</h2><p>thrift的命名空间相当于Java中的package的意思，主要目的是组织代码。thrift使用关键字namespace定义命名空间，例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace java com<span class="class">.winwill</span><span class="class">.thrift</span></span><br></pre></td></tr></table></figure>
<p><strong>格式是：namespace 语言名 路径， 注意末尾不能有分号。</strong></p>
<h2 id="文件包含">文件包含</h2><p>thrift也支持文件包含，相当于C/C++中的include，Java中的import。使用关键字include定义，例 如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">"global.thrift"</span></span><br></pre></td></tr></table></figure>
<h2 id="注释">注释</h2><p>thrift注释方式支持shell风格的注释，支持C/C++风格的注释，即#和//开头的语句都单当做注释，/**/包裹的语句也是注释。</p>
<h2 id="可选与必选">可选与必选</h2><p>thrift提供两个关键字required，optional，分别用于表示对应的字段时必填的还是可选的。例如：</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">optional</span> <span class="built_in">i32</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示name是必填的，age是可选的。</p>
<h1 id="生成代码">生成代码</h1><p> 知道了怎么定义thirtf文件之后，我们需要用定义好的thrift文件生成我们需要的目标语言的源码，本文以生成java源码为例。假设现在定义了如下一个thrift文件：</p>
 <figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.winwill.thrift</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RequestType</span> </span>&#123;</span><br><span class="line">    SAY_HELLO,   <span class="comment">//问好</span></span><br><span class="line">    QUERY_TIME,  <span class="comment">//询问时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> RequestType type;  <span class="comment">// 请求的类型，必选</span></span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> name;       <span class="comment">// 发起请求的人的名字，必选</span></span><br><span class="line">    <span class="number">3</span>: <span class="keyword">optional</span> <span class="built_in">i32</span> age;           <span class="comment">// 发起请求的人的年龄，可选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">exception</span> <span class="title">RequestException</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">i32</span> code;</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">optional</span> <span class="built_in">string</span> reason;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务名</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloWordService</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> doAction(<span class="number">1</span>: Request request) throws (<span class="number">1</span>:RequestException qe); <span class="comment">// 可能抛出异常。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在终端运行如下命令(前提是已经安装thrift)：</p>
 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift --<span class="keyword">gen</span> java <span class="keyword">Test</span>.thrift</span><br></pre></td></tr></table></figure>
<p> 则在当前目录会生成一个gen-java目录，该目录下会按照namespace定义的路径名一次一层层生成文件夹，到gen-java/com/winwill/thrift/目录下可以看到生成的4个Java类：<br> <img src="http://7xlune.com1.z0.glb.clouddn.com/images/Thrift入门教程/thrift-gen-java.png" alt="目录结构"><br> 可以看到，thrift文件中定义的enum，struct，exception，service都相应地生成了一个Java类，这就是能支持Java语言的基本的框架代码。</p>
<h1 id="服务端实现">服务端实现</h1><p>上面代码生成这一步已经将接口代码生成了，现在需要做的是实现HelloWordService的具体逻辑，实现的方式就是创建一个Java类，implements com.winwill.thrift.HelloWordService，例如：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.winwill.thrift;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.<span class="type">StringUtils</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.<span class="type">TException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author qifuguang</span><br><span class="line"> * @date <span class="number">15</span>/<span class="number">9</span>/<span class="number">11</span> <span class="number">15</span>:<span class="number">53</span></span><br><span class="line"> */</span><br><span class="line">public class <span class="type">HelloWordServiceImpl</span> implements com.winwill.thrift.<span class="type">HelloWordService</span>.<span class="type">Iface</span> &#123;</span><br><span class="line">    // 实现这个方法完成具体的逻辑。</span><br><span class="line">    public <span class="type">String</span> doAction(com.winwill.thrift.<span class="type">Request</span> request) throws com.winwill.thrift.<span class="type">RequestException</span>, <span class="type">TException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Get request: "</span> + request);</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">StringUtils</span>.isBlank(request.getName()) || request.getType() == null) &#123;</span><br><span class="line">            throw new com.winwill.thrift.<span class="type">RequestException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="literal">result</span> = <span class="string">"Hello, "</span> + request.getName();</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == com.winwill.thrift.<span class="type">RequestType</span>.<span class="type">SAY_HELLO</span>) &#123;</span><br><span class="line">            <span class="literal">result</span> += <span class="string">", Welcome!"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">result</span> += <span class="string">", Now is "</span> + new <span class="type">Date</span>().toLocaleString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="启动服务">启动服务</h1><p>上面这个就是服务端的具体实现类，现在需要启动这个服务，所以需要一个启动类，启动类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.winwill.thrift;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.TServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.TSimpleServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> qifuguang</span><br><span class="line"> * <span class="doctag">@date</span> 15/9/11 16:07</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">7912</span>);</span><br><span class="line">        TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(socket);</span><br><span class="line">        com.winwill.thrift.HelloWordService.Processor processor = <span class="keyword">new</span> com.winwill.thrift.HelloWordService.Processor(<span class="keyword">new</span> HelloWordServiceImpl());</span><br><span class="line">        TServer server = <span class="keyword">new</span> TSimpleServer(processor, serverTransport);</span><br><span class="line">        System.out.println(<span class="string">"Running server..."</span>);</span><br><span class="line">        server.serve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后看到控制台的输出为：</p>
<blockquote>
<p>Running server…</p>
</blockquote>
<h1 id="客户端请求">客户端请求</h1><p>现在服务已经启动，可以通过客户端向服务端发送请求了，客户端的代码如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.winwill.thrift;</span><br><span class="line"></span><br><span class="line"><span class="built_in">import</span> org.apache.thrift.protocol.TBinaryProtocol;</span><br><span class="line"><span class="built_in">import</span> org.apache.thrift.protocol.TProtocol;</span><br><span class="line"><span class="built_in">import</span> org.apache.thrift.transport.TSocket;</span><br><span class="line"><span class="built_in">import</span> org.apache.thrift.transport.TTransport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @author qifuguang</span><br><span class="line"> * @date 15/9/11 16:13</span><br><span class="line"> */</span></span><br><span class="line">public class HelloWordClient &#123;</span><br><span class="line">    public static void main<span class="params">(String[] args)</span> throws Exception &#123;</span><br><span class="line">        TTransport transport = new TSocket<span class="params">(<span class="string">"localhost"</span>, <span class="number">8888</span>)</span>;</span><br><span class="line">        TProtocol protocol = new TBinaryProtocol<span class="params">(transport)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建client</span></span><br><span class="line">        com.winwill.thrift.HelloWordService.Client client = new com.winwill.thrift.HelloWordService.Client<span class="params">(protocol)</span>;</span><br><span class="line"></span><br><span class="line">        transport.open<span class="params">()</span>;  <span class="comment">// 建立连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种请求类型</span></span><br><span class="line">        com.winwill.thrift.Request request = new com.winwill.thrift.Request<span class="params">()</span></span><br><span class="line">                .setType<span class="params">(com.winwill.thrift.RequestType.SAY_HELLO)</span>.setName<span class="params">(<span class="string">"飞鸟"</span>)</span>.setAge<span class="params">(<span class="number">24</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(client.doAction<span class="params">(request)</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种请求类型</span></span><br><span class="line">        request.setType<span class="params">(com.winwill.thrift.RequestType.QUERY_TIME)</span>.setName<span class="params">(<span class="string">"飞鸟"</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(client.doAction<span class="params">(request)</span>)</span>;</span><br><span class="line"></span><br><span class="line">        transport.close<span class="params">()</span>;  <span class="comment">// 请求结束，断开连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行客户端代码，得到结果：</p>
<blockquote>
<p>Hello, 飞鸟, Welcome!<br>Hello, 飞鸟, Now is 2015-9-11 16:37:22</p>
</blockquote>
<p>并且此时，服务端会有请求日志：</p>
<blockquote>
<p>Running server…<br>Get request: Request(type:SAY_HELLO, name:飞鸟, age:24)<br>Get request: Request(type:QUERY_TIME, name:飞鸟, age:24)  </p>
</blockquote>
<p>可以看到，客户端成功将请求发到了服务端，服务端成功地将请求结果返回给客户端，整个通信过程完成。</p>
<h1 id="注意事项">注意事项</h1><ul>
<li>本文为作者个人理解，如理解有误，请留言相告，感激不尽；</li>
<li>本文为作者原创，转载请注明出处，原文地址：<a href="http://fudawei.github.io/2015/09/11/Thrift入门教程/">http://fudawei.github.io/2015/09/11/Thrift入门教程/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，支持跨语言，常用的语言比如C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml都支持。Thrift是一个典型的CS（客户端/服务端）结构，客户端和服务端可以使用不同的语言开发。既然客户端和服务端能使用不同的语言开发，那么一定就要有一种中间语言来关联客户端和服务端的语言，没错，这种语言就是IDL（Interface Description Language）。<br>]]>
    
    </summary>
    
      <category term="thrift" scheme="http://fudawei.github.io/tags/thrift/"/>
    
      <category term="thrift" scheme="http://fudawei.github.io/categories/thrift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Java并发包学习八]深度剖析ConcurrentHashMap]]></title>
    <link href="http://fudawei.github.io/2015/09/10/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E5%85%AB%5D%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90ConcurrentHashMap/"/>
    <id>http://fudawei.github.io/2015/09/10/[Java并发包学习八]深度剖析ConcurrentHashMap/</id>
    <published>2015-09-10T15:07:52.000Z</published>
    <updated>2015-12-30T06:02:16.168Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>还记得大学快毕业的时候要准备找工作了，然后就看各种面试相关的书籍，还记得很多面试书中都说到：</p>
<blockquote>
<p>HashMap是非线程安全的，HashTable是线程安全的。</p>
</blockquote>
<p>那个时候没怎么写Java代码，所以根本就没有听说过ConcurrentHashMap，只知道面试的时候就记住这句话就行了…至于为什么是线程安全的，内部怎么实现的，通通不了解。<br><a id="more"></a><br>今天我们将深入剖析一个比HashTable性能更优的线程安全的Map类，它就是ConcurrentHashMap，<strong>本文基于Java 7的源码做剖析</strong>。</p>
<h1 id="ConcurrentHashMap的目的">ConcurrentHashMap的目的</h1><p>多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。虽然已经有一个线程安全的HashTable，但是HashTable容器使用synchronized（他的get和put方法的实现代码如下）来保证线程安全，在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，访问其他同步方法的线程就可能会进入阻塞或者轮训状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="variable">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.<span class="variable">key</span>.equals(<span class="variable">key</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V put(K <span class="variable">key</span>, V value) &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="variable">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.<span class="variable">key</span>.equals(<span class="variable">key</span>)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, <span class="variable">key</span>, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这么恶劣的环境下，ConcurrentHashMap应运而生。</p>
<h1 id="实现原理">实现原理</h1><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/深入剖析ConcurrentHashMap/ConcurrentHashMap.png" alt=""><br>从图中可以看到，ConcurrentHashMap内部分为很多个Segment，每一个Segment拥有一把锁，然后每个Segment（继承ReentrantLock）下面包含很多个HashEntry列表数组。对于一个key，需要经过三次（为什么要hash三次下文会详细讲解）hash操作，才能最终定位这个元素的位置，这三次hash分别为：</p>
<ol>
<li>对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = hash1(key)；</li>
<li>将得到的h1的高几位进行第二次hash，得到hash值h2，也即h2 = hash2(h1高几位)，通过h2能够确定该元素的放在哪个Segment；</li>
<li>将得到的h1进行第三次hash，得到hash值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。</li>
</ol>
<h2 id="初始化">初始化</h2><p>先看看ConcurrentHashMap的初始化做了哪些事情，构造函数的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>传入的参数有initialCapacity，loadFactor，concurrencyLevel这三个。</p>
<ul>
<li>initialCapacity表示新创建的这个ConcurrentHashMap的初始容量，也就是上面的结构图中的Entry数量。默认值为<code>static final int DEFAULT_INITIAL_CAPACITY = 16;</code></li>
<li>loadFactor表示负载因子，就是当ConcurrentHashMap中的元素个数大于<strong>loadFactor * 最大容量</strong>时就需要rehash，扩容。默认值为<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></li>
<li>concurrencyLevel表示并发级别，这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为<code>static final int DEFAULT_CONCURRENCY_LEVEL = 16;</code>。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。</li>
</ul>
<p>初始化的一些动作：</p>
<ol>
<li>验证参数的合法性，如果不合法，直接抛出异常。</li>
<li>concurrencyLevel也就是Segment的个数不能超过规定的最大Segment的个数，默认值为<code>static final int MAX_SEGMENTS = 1 &lt;&lt; 16;</code>，如果超过这个值，设置为这个值。</li>
<li>然后使用循环找到大于等于concurrencyLevel的第一个2的n次方的数ssize，这个数就是Segment数组的大小，并记录一共向左按位移动的次数sshift，并令<code>segmentShift = 32 - sshift</code>，并且segmentMask的值等于ssize - 1，segmentMask的各个二进制位都为1，目的是之后可以通过key的hash值与这个值做<strong>&amp;运算</strong>确定Segment的索引。</li>
<li>检查给的容量值是否大于允许的最大容量值，如果大于该值，设置为该值。最大容量值为<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>。</li>
<li>然后计算每个Segment平均应该放置多少个元素，这个值c是向上取整的值。比如初始容量为15，Segment个数为4，则每个Segment平均需要放置4个元素。</li>
<li>最后创建一个Segment实例，将其当做Segment数组的第一个元素。</li>
</ol>
<h2 id="put操作">put操作</h2><p>put操作的源码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">      Segment&lt;K,V&gt; s;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">      <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">      <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">          s = ensureSegment(j);</span><br><span class="line">      <span class="keyword">return</span> s.put(key, hash, <span class="keyword">value</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>操作步骤如下：</p>
<ol>
<li>判断value是否为null，如果为null，直接抛出异常。</li>
<li>key通过一次hash运算得到一个hash值。(这个hash运算下文详说)</li>
<li>将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&amp;运算得到segment的索引j。<br>在初始化的时候我们说过segmentShift的值等于32-sshift，例如concurrencyLevel等于16，则sshift等于4，则segmentShift为28。hash值是一个32位的整数，将其向右移动28位就变成这个样子：<br>0000 0000 0000 0000 0000 0000 0000 xxxx，然后再用这个值与segmentMask做&amp;运算，也就是取最后四位的值。这个值确定Segment的索引。</li>
<li>使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。</li>
<li>向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&amp;运算获取HashEntry的索引，然后set）。</li>
</ol>
<h2 id="get操作">get操作</h2><p>get操作的源码如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public V get<span class="params">(Object key)</span> &#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        int h = hash<span class="params">(key)</span>;</span><br><span class="line">        long u = <span class="params">(<span class="params">(<span class="params">(h &gt;&gt;&gt; segmentShift)</span> &amp; segmentMask)</span> &lt;&lt; SSHIFT)</span> + SBASE;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(<span class="params">(s = <span class="params">(Segment&lt;K,V&gt;)</span>UNSAFE.getObjectVolatile<span class="params">(segments, u)</span>)</span> != null &amp;&amp;</span><br><span class="line">            <span class="params">(tab = s.table)</span> != null)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="params">(HashEntry&lt;K,V&gt; e = <span class="params">(HashEntry&lt;K,V&gt;)</span> UNSAFE.getObjectVolatile</span><br><span class="line">                     <span class="params">(tab, <span class="params">(<span class="params">(long)</span><span class="params">(<span class="params">(<span class="params">(tab.length - <span class="number">1</span>)</span> &amp; h)</span>)</span> &lt;&lt; TSHIFT)</span> + TBASE)</span>;</span><br><span class="line">                 e != null; e = e.next)</span> &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(<span class="params">(k = e.key)</span> == key || <span class="params">(e.hash == h &amp;&amp; key.equals<span class="params">(k)</span>)</span>)</span></span><br><span class="line">                    return e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>操作步骤为：</p>
<ol>
<li>和put操作一样，先通过key进行两次hash确定应该去哪个Segment中取数据。</li>
<li>使用Unsafe获取对应的Segment，然后再进行一次&amp;运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。</li>
</ol>
<h2 id="size操作">size操作</h2><p>size操作与put和get操作最大的区别在于，size操作需要遍历所有的Segment才能算出整个Map的大小，而put和get都只关心一个Segment。假设我们当前遍历的Segment为SA，那么在遍历SA过程中其他的Segment比如SB可能会被修改，于是这一次运算出来的size值可能并不是Map当前的真正大小。所以一个比较简单的办法就是计算Map大小的时候所有的Segment都Lock住，不能更新(包含put，remove等等)数据，计算完之后再Unlock。这是普通人能够想到的方案，但是牛逼的作者还有一个更好的Idea：<strong>先给3次机会，不lock所有的Segment，遍历所有Segment，累加各个Segment的大小得到整个Map的大小，如果某相邻的两次计算获取的所有Segment的更新的次数（每个Segment都有一个modCount变量，这个变量在Segment中的Entry被修改时会加一，通过这个值可以得到每个Segment的更新操作的次数）是一样的，说明计算过程中没有更新操作，则直接返回这个值。如果这三次不加锁的计算过程中Map的更新次数有变化，则之后的计算先对所有的Segment加锁，再遍历所有Segment计算Map大小，最后再解锁所有Segment。</strong>源代码如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> size() &#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">sum</span>;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0</span>L;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">sum</span> = <span class="number">0</span>L;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">sum</span> += seg.modCount;</span><br><span class="line">                        <span class="keyword">int</span> c = seg.<span class="keyword">count</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">sum</span> == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = <span class="keyword">sum</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<blockquote>
<p>一个Map有4个Segment，标记为S1，S2，S3，S4，现在我们要获取Map的size。计算过程是这样的：第一次计算，不对S1，S2，S3，S4加锁，遍历所有的Segment，假设每个Segment的大小分别为1，2，3，4，更新操作次数分别为：2，2，3，1，则这次计算可以得到Map的总大小为1+2+3+4=10，总共更新操作次数为2+2+3+1=8；第二次计算，不对S1,S2,S3,S4加锁，遍历所有Segment，假设这次每个Segment的大小变成了2，2，3，4，更新次数分别为3，2，3，1，因为两次计算得到的Map更新次数不一致(第一次是8，第二次是9)则可以断定这段时间Map数据被更新，则此时应该再试一次；第三次计算，不对S1，S2，S3，S4加锁，遍历所有Segment，假设每个Segment的更新操作次数还是为3，2，3，1，则因为第二次计算和第三次计算得到的Map的更新操作的次数是一致的，就能说明第二次计算和第三次计算这段时间内Map数据没有被更新，此时可以直接返回第三次计算得到的Map的大小。最坏的情况：第三次计算得到的数据更新次数和第二次也不一样，则只能先对所有Segment加锁再计算最后解锁。</p>
</blockquote>
<h2 id="containsValue操作">containsValue操作</h2><p>containsValue操作采用了和size操作一样的想法:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> containsValue(Object value) &#123;</span><br><span class="line">        <span class="comment">// Same idea as size()</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> hashSum = <span class="number">0</span>L;</span><br><span class="line">                <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (tab = seg.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tab.length; i++) &#123;</span><br><span class="line">                            HashEntry&lt;K,V&gt; e;</span><br><span class="line">                            <span class="keyword">for</span> (e = entryAt(tab, i); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                V v = e.value;</span><br><span class="line">                                <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)) &#123;</span><br><span class="line">                                    found = <span class="keyword">true</span>;</span><br><span class="line">                                    <span class="keyword">break</span> outer;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">sum</span> += seg.modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (retries &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">sum</span> == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = <span class="keyword">sum</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于hash">关于hash</h1><p>大家一定还记得使用一个key定位Segment之前进行过一次hash操作吧？这次hash的作用是什么呢？看看hash的源代码：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private int hash(Object k) &#123;</span><br><span class="line">        int <span class="keyword">h</span> = hashSeed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((0 != <span class="keyword">h</span>) &amp;&amp; (k instanceof String)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">h</span> ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">        <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">        <span class="keyword">h</span> += (<span class="keyword">h</span> &lt;&lt;  15) ^ 0xffffcd7d;</span><br><span class="line">        <span class="keyword">h</span> ^= (<span class="keyword">h</span> &gt;&gt;&gt; 10);</span><br><span class="line">        <span class="keyword">h</span> += (<span class="keyword">h</span> &lt;&lt;   3);</span><br><span class="line">        <span class="keyword">h</span> ^= (<span class="keyword">h</span> &gt;&gt;&gt;  6);</span><br><span class="line">        <span class="keyword">h</span> += (<span class="keyword">h</span> &lt;&lt;   2) + (<span class="keyword">h</span> &lt;&lt; 14);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">h</span> ^ (<span class="keyword">h</span> &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>源码中的注释是这样的：</p>
<blockquote>
<p>Applies a supplemental hash function to a given hashCode, which defends against poor quality hash functions.  This is critical because ConcurrentHashMap uses power-of-two length hash tables, that otherwise encounter collisions for hashCodes that do not differ in lower or upper bits.</p>
</blockquote>
<p>这里用到了Wang/Jenkins hash算法的变种，主要的目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。</p>
<p>举个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.parseInt(<span class="string">"0001111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">"0011111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">"0111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">"1111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>这些数字得到的hash值都是一样的，全是15，所以如果不进行第一次预hash，发生冲突的几率还是很大的，但是如果我们先把上例中的二进制数字使用hash()函数先进行一次预hash，得到的结果是这样的：</p>
<blockquote>
<p>0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110<br>1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000<br>0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110<br>1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010  </p>
</blockquote>
<p>上面这个例子引用自: <a href="http://www.infoq.com/cn/articles/ConcurrentHashMap/" target="_blank" rel="external">InfoQ</a><br>可以看到每一位的数据都散开了，并且ConcurrentHashMap中是使用预hash值的高位参与运算的。比如之前说的先将hash值向右按位移动28位，再与15做&amp;运算，得到的结果都别为：4，15，7，8，没有冲突！</p>
<h1 id="注意事项">注意事项</h1><ul>
<li>ConcurrentHashMap中的key和value值都不能为null。</li>
<li>ConcurrentHashMap的整个操作过程中大量使用了Unsafe类来获取Segment/HashEntry，这里Unsafe的主要作用是提供原子操作。Unsafe这个类比较恐怖，破坏力极强，一般场景不建议使用，如果有兴趣可以到这里做详细的了解<a href="http://blog.csdn.net/fenglibing/article/details/17138079" target="_blank" rel="external">Java中鲜为人知的特性</a></li>
<li>ConcurrentHashMap是线程安全的类并不能保证使用了ConcurrentHashMap的操作都是线程安全的！</li>
<li>本文为作者个人理解，如果有误，请留言相告，感激不尽。</li>
<li>转载请注明出处：<a href="http://fudawei.github.io/2015/09/10/[Java并发包学习八]深度剖析ConcurrentHashMap/">http://fudawei.github.io/2015/09/10/[Java并发包学习八]深度剖析ConcurrentHashMap/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>还记得大学快毕业的时候要准备找工作了，然后就看各种面试相关的书籍，还记得很多面试书中都说到：</p>
<blockquote>
<p>HashMap是非线程安全的，HashTable是线程安全的。</p>
</blockquote>
<p>那个时候没怎么写Java代码，所以根本就没有听说过ConcurrentHashMap，只知道面试的时候就记住这句话就行了…至于为什么是线程安全的，内部怎么实现的，通通不了解。<br>]]>
    
    </summary>
    
      <category term="Java并发包学习" scheme="http://fudawei.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Java并发包学习" scheme="http://fudawei.github.io/categories/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UTF8编码]]></title>
    <link href="http://fudawei.github.io/2015/09/08/UTF8%E7%BC%96%E7%A0%81/"/>
    <id>http://fudawei.github.io/2015/09/08/UTF8编码/</id>
    <published>2015-09-07T16:07:17.000Z</published>
    <updated>2015-12-30T05:33:54.978Z</updated>
    <content type="html"><![CDATA[<h1 id="编码">编码</h1><p>大家都知道，计算机中的数据都是以二进制的形式保存的，所以如果需要在计算机中存储或者在网络上传输一些字符的话，就需要用某种规则将这些字符编排成一串串的二进制数据，就像011010101011110101101这样，这个编排的过程就叫做“字符编码”。</p>
<a id="more"></a>
<h1 id="Unicode编码">Unicode编码</h1><p>Unicode出现之前，各个国家或地区都有自己的编码方式，非常混乱，这极大地阻碍了网络信息在全世界范围内的传播与交流。所以有有一个叫ISO的牛逼组织做了一个伟大的创想：<strong>统一天下编码方式，让信息传播归一化。</strong>这个创想的结果就是制定了Unicode编码规则。</p>
<p>Unicode 是为了解决传统的字符编码方案的局限而产生的，例如ISO 8859所定义的字符虽然在不同的国家中广泛地使用，可是在不同国家间却经常出现不兼容的情况。很多传统的编码方式都有一个共同的问题，即容许电脑处理双语环境（通常使用拉丁字母以及其本地语言），但却无法同时支持多语言环境（指可同时处理多种语言混合的情况）。</p>
<p>Unicode可以容纳世界上所有的文字和字符。Unicode目有两套编码方法,UCS-2(Unicode-16)用2个字节表示一个字符,UCS-4(Unicode-32)用4个字节表示一个字符。UCS-4是由USC-2扩展来的,增加了2字节的高位。即使是老UCS-2,它也可以表示2^16=65535个字符,基本上可以容纳所有常用各国字符,所以目前基本都使用UCS-2。</p>
<h1 id="UTF8编码">UTF8编码</h1><p>Unicode使用2个字节表示一个字符，ASCII码使用1个字节，所以在很多方面产生了冲突，以前处理ASCII的方法都必须重写。而且C语言用\0作为字符串结束标志,但Unicode中很多字符都含\0,C语言的字符串函数也无法正常处理Unicode。为了把unicode投入实用,出现了UTF,最常见的是UTF-8和UTF-16。<br>其中UTF-16和Unicode本身的编码是一致的，都是使用两个字节编码字符，但是因为ASCII本身只需要一个字节，这就会造成空间的浪费。UTF-32和UCS-4也是相同的。</p>
<p>主角该出场了：UTF8是一种变长的编码，它的字节数是不固定的,使用第一个字节确定字节数。第一个字节首为0即一个字节，110即2字节，1110即3字节，字符后续字节都用10开始，这样不会混淆且单字节英文字符可仍用ASCII编码。理论上UTF-8最大可以用6字节表示一个字符，但Unicode目前没有用大于0xffff的字符，实际UTF-8最多使用了3个字节。Unicode到UTF8的转换规则如下表：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/UTF8编码/utf8.png" alt=""></p>
<p>举个栗子：</p>
<p>‘强’字的unicode编码为：<code>5F3A</code>，我们对照上表将其转换成UTF8编码：</p>
<ol>
<li>5F3A在区间[0800,07FF]，所以转换成UTF8之后应该是3个字节。</li>
<li>5F3A写成二进制形式是：0101 1111 0011 1010。</li>
<li>按照UTF8的模板依次从高位取4/6/6位二进制数填入模板，得到11100101 10111100 10111010。</li>
<li>转成16进制之后得到: E5 BC BA，这就是’强’字的UTF8编码。</li>
<li>Java程序验证一把，程序如下：</li>
</ol>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.winwill.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @author qifuguang</span><br><span class="line"> * @date 15/9/6 23:37</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class TestEncode &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] utf8s = <span class="string">"强"</span>.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"编码字节数："</span> + utf8s.length);</span><br><span class="line">        System.out.<span class="built_in">print</span>(<span class="string">"编码结果："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; utf8s.length; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="keyword">String</span>.format(<span class="string">"%x"</span>, utf8s[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<blockquote>
<p>编码字节数：3<br>编码结果：e5bcba</p>
</blockquote>
<p>可见，整个编码过程就是这样的，没错！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="编码">编码</h1><p>大家都知道，计算机中的数据都是以二进制的形式保存的，所以如果需要在计算机中存储或者在网络上传输一些字符的话，就需要用某种规则将这些字符编排成一串串的二进制数据，就像011010101011110101101这样，这个编排的过程就叫做“字符编码”。</p>]]>
    
    </summary>
    
      <category term="编码" scheme="http://fudawei.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="编码" scheme="http://fudawei.github.io/categories/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序员八荣八耻]]></title>
    <link href="http://fudawei.github.io/2015/09/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB/"/>
    <id>http://fudawei.github.io/2015/09/04/程序员八荣八耻/</id>
    <published>2015-09-04T02:33:36.000Z</published>
    <updated>2015-12-30T05:33:54.986Z</updated>
    <content type="html"><![CDATA[<p>以动手实践为荣，以只看不练为耻。<br>以打印日志为荣，以出错不报为耻。<br>以局部变量为荣，以全局变量为耻。<br>以单元测试为荣，以手工测试为耻。<br>以代码重用为荣，以复制粘贴为耻。<br>以多态应用为荣，以分支判断为耻。<br>以定义常量为荣，以魔法数字为耻。<br>以总结思考为荣，以不求甚解为耻。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以动手实践为荣，以只看不练为耻。<br>以打印日志为荣，以出错不报为耻。<br>以局部变量为荣，以全局变量为耻。<br>以单元测试为荣，以手工测试为耻。<br>以代码重用为荣，以复制粘贴为耻。<br>以多态应用为荣，以分支判断为耻。<br>以定义常量为荣，以魔法数字为耻。<]]>
    </summary>
    
      <category term="杂谈" scheme="http://fudawei.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="杂谈" scheme="http://fudawei.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[git]git命令自动补全]]></title>
    <link href="http://fudawei.github.io/2015/09/02/%5Bgit%5Dgit%E5%91%BD%E4%BB%A4%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/"/>
    <id>http://fudawei.github.io/2015/09/02/[git]git命令自动补全/</id>
    <published>2015-09-02T08:58:32.000Z</published>
    <updated>2015-12-30T05:33:54.990Z</updated>
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>在Mac上安装了git之后，发现命令不能自动补全，使用起来非常不方便，本文介绍怎么让git命令能够自动补全。<br><a id="more"></a></p>
<h1 id="确保bash能够自动补全">确保bash能够自动补全</h1><p>在终端（本文使用的是OS X的终端）执行如下命令：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew <span class="type">list</span></span><br></pre></td></tr></table></figure>
<p>看看是否已经安装有bash-completion，比如我的机器(已经安装了)运行上面的命令会显示：</p>
<blockquote>
<p>bash-completion    node        openssl        pkg-config    wget</p>
</blockquote>
<p>如果没有安装，运行如下命令安装bash-completion：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>install <span class="keyword">bash-completion</span></span><br></pre></td></tr></table></figure>
<p>等待安装完成之后，运行如下命令：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="preprocessor">info</span> <span class="keyword">bash-completion</span></span><br></pre></td></tr></table></figure>
<p>运行上面的命令后会在终端显示下图：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/git命令自动补全/bash-completion.png" alt=""></p>
<p>仔细阅读箭头所指的地方，依照提示将矩形框内的内容添加到~/.bash_profile文件(如果没有该文件，新建)，然后重启终端，bash-completion功能安装完成。</p>
<h1 id="让git支持自动补全">让git支持自动补全</h1><p>从github上clone git的源码到本地：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="string">https:</span><span class="comment">//github.com/git/git.git</span></span><br></pre></td></tr></table></figure>
<p>找到”contrib/completion/“目录下的git-completion.bash，将该文件拷贝到<code>~/</code>目录下下并重命名为.git-completion.bash:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp git-completion<span class="class">.bash</span> ~/<span class="class">.git-completion</span><span class="class">.bash</span></span><br></pre></td></tr></table></figure>
<p>在~/.bashrc文件中追加如下内容：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/<span class="class">.git-completion</span><span class="class">.bash</span></span><br></pre></td></tr></table></figure>
<p>重启终端，大功告成，现在git能够使用tab键自动补全命令了，enjoy it！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="背景">背景</h1><p>在Mac上安装了git之后，发现命令不能自动补全，使用起来非常不方便，本文介绍怎么让git命令能够自动补全。<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://fudawei.github.io/tags/git/"/>
    
      <category term="git" scheme="http://fudawei.github.io/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Java并发包学习七]解密ThreadLocal]]></title>
    <link href="http://fudawei.github.io/2015/09/02/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83%5D%E8%A7%A3%E5%AF%86ThreadLocal/"/>
    <id>http://fudawei.github.io/2015/09/02/[Java并发包学习七]解密ThreadLocal/</id>
    <published>2015-09-01T17:21:19.000Z</published>
    <updated>2015-12-30T06:02:16.168Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>相信读者在网上也看了很多关于ThreadLocal的资料，很多博客都这样说：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。如果你也这样认为的，那现在给你10秒钟，清空之前对ThreadLocal的<strong>错误</strong>的认知！<br><a id="more"></a><br>看看JDK中的源码是怎么写的：</p>
<blockquote>
<p>This class provides thread-local variables.  These variables differ from<br> their normal counterparts in that each thread that accesses one (via its<br> {@code get} or {@code set} method) has its own, independently initialized<br> copy of the variable.  {@code ThreadLocal} instances are typically private<br> static fields in classes that wish to associate state with a thread (e.g.,<br> a user ID or Transaction ID).</p>
</blockquote>
<p>翻译过来大概是这样的(英文不好，如有更好的翻译，请留言说明)：  </p>
<blockquote>
<p>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是<code>private static</code>类型的，用于关联线程和线程的上下文。</p>
</blockquote>
<p>可以总结为一句话：<strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</strong><br>举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。</p>
<p>有人要说了：<em>你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？</em>但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p>
<h1 id="ThreadLocal基本操作">ThreadLocal基本操作</h1><h2 id="构造函数">构造函数</h2><p>ThreadLocal的构造函数签名是这样的：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Creates a thread local variable.</span><br><span class="line"> <span class="keyword">*</span> <span class="comment">@see #withInitial(java.util.function.Supplier)</span></span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">public ThreadLocal() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部啥也没做。</p>
<h2 id="initialValue函数">initialValue函数</h2><p>initialValue函数用来设置ThreadLocal的初始值，函数签名如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function">T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数在调用<code>get</code>函数的时候会第一次调用，但是如果一开始就调用了<code>set</code>函数，则该函数不会被调用。通常该函数只会被调用一次，除非手动调用了<code>remove</code>函数之后又调用<code>get</code>函数，这种情况下，<code>get</code>函数中还是会调用<code>initialValue</code>函数。该函数是protected类型的，很显然是建议在子类重载该函数的，所以通常该函数都会以匿名内部类的形式被重载，以指定初始值，比如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.winwill.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> qifuguang</span><br><span class="line"> * <span class="doctag">@date</span> 15/9/2 00:05</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function">Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Integer.<span class="title">valueOf</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get函数">get函数</h2><p>该函数用来获取与当前线程关联的ThreadLocal的值，函数签名如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public T <span class="function"><span class="title">get</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果当前线程没有该ThreadLocal的值，则调用<code>initialValue</code>函数获取初始值返回。</p>
<h2 id="set函数">set函数</h2><p>set函数用来设置当前线程的该ThreadLocal的值，函数签名如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">set</span>(T value)</span><br></pre></td></tr></table></figure>
<p>设置当前线程的ThreadLocal的值为value。</p>
<h2 id="remove函数">remove函数</h2><p>remove函数用来将当前线程的ThreadLocal绑定的值删除，函数签名如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">remove</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在某些情况下需要手动调用该函数，防止内存泄露。</p>
<h1 id="代码演示">代码演示</h1><p>学习了最基本的操作之后，我们用一段代码来演示ThreadLocal的用法，该例子实现下面这个场景：</p>
<blockquote>
<p>有5个线程，这5个线程都有一个值value，初始值为0，线程运行时用一个循环往value值相加数字。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.winwill.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @author qifuguang</span><br><span class="line"> * @date 15/9/2 00:05</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;Integer&gt; <span class="keyword">value</span> = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        @<span class="function">Override</span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title">initialValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span>(<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"线程"</span> + index + <span class="string">"的初始value:"</span> + <span class="keyword">value</span>.<span class="keyword">get</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">value</span>.<span class="keyword">set</span>(<span class="keyword">value</span>.<span class="keyword">get</span>() + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"线程"</span> + index + <span class="string">"的累加value:"</span> + <span class="keyword">value</span>.<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<blockquote>
<p>线程0的初始value:0<br>线程3的初始value:0<br>线程2的初始value:0<br>线程2的累加value:45<br>线程1的初始value:0<br>线程3的累加value:45<br>线程0的累加value:45<br>线程1的累加value:45<br>线程4的初始value:0<br>线程4的累加value:45  </p>
</blockquote>
<p>可以看到，各个线程的value值是相互独立的，本线程的累加操作不会影响到其他线程的值，真正达到了线程内部隔离的效果。</p>
<h1 id="如何实现的">如何实现的</h1><p>看了基本介绍，也看了最简单的效果演示之后，我们更应该好好研究下ThreadLocal内部的实现原理。如果给你设计，你会怎么设计？相信大部分人会有这样的想法：  </p>
<blockquote>
<p>每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。</p>
</blockquote>
<p>没错，这是最简单的设计方案，JDK最早期的ThreadLocal就是这样设计的。JDK1.3（不确定是否是1.3）之后ThreadLocal的设计换了一种方式。</p>
<p>我们先看看JDK8的ThreadLocal的<code>get</code>方法的源码:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">      <span class="type">Thread</span> t = <span class="type">Thread</span>.currentThread();</span><br><span class="line">      <span class="type">ThreadLocalMap</span> map = getMap(t);</span><br><span class="line">      <span class="keyword">if</span> (map != null) &#123;</span><br><span class="line">          <span class="type">ThreadLocalMap</span>.<span class="type">Entry</span> e = map.getEntry(this);</span><br><span class="line">          <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">              @<span class="type">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">              T <span class="literal">result</span> = (T)e.value;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> setInitialValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中getMap的源码：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setInitialValue函数的源码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    T <span class="keyword">value</span> = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</span><br><span class="line">    <span class="function"><span class="keyword">else</span></span><br><span class="line">        <span class="title">createMap</span>(<span class="params">t, <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createMap函数的源码：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解析一下，get方法的流程是这样的：  </p>
<ol>
<li>首先获取当前线程</li>
<li>根据当前线程获取一个Map</li>
<li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e，否则转到5</li>
<li>如果e不为null，则返回e.value，否则转到5</li>
<li>Map为空或者e为空，则通过<code>initialValue</code>函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</li>
</ol>
<p>然后需要注意的是Thread类中包含一个成员变量：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>所以，可以总结一下ThreadLocal的设计思路：<br><strong>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。</strong><br>这个方案刚好与我们开始说的简单的设计方案相反。查阅了一下资料，这样设计的主要有以下几点优势：  </p>
<ul>
<li>这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量，能提高性能，据说性能的提升不是一点两点(没有亲测)</li>
<li>当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</li>
</ul>
<h1 id="再深入一点">再深入一点</h1><p>先交代一个事实：<strong>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</strong>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * The entries in this hash map extend WeakReference, using</span><br><span class="line">         * its main ref field as the key (which is always a</span><br><span class="line">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="line">         * == null) mean that the key is no longer referenced, so the</span><br><span class="line">         * entry can be expunged from table.  Such entries are referred to</span><br><span class="line">         * as "stale entries" in the code that follows.</span><br><span class="line">         */</span></span><br><span class="line">        static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> &#123;</span></span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            <span class="type">Object</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/解密ThreadLocal/ThreadLocal.png" alt=""></p>
<p>然后网上就传言，ThreadLocal会引发内存泄露，他们的理由是这样的：</p>
<blockquote>
<p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br><strong>ThreadLocal Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong><br>永远无法回收，造成内存泄露。</p>
</blockquote>
<p>我们来看看到底会不会出现这种情况。<br>其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的<code>getEntry</code>方法的源码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry getEntry(ThreadLocal&lt;?&gt; <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="variable">key</span>.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.<span class="built_in">get</span>() == <span class="variable">key</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(<span class="variable">key</span>, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getEntryAfterMiss</code>函数的源码：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry <span class="keyword">e</span>) &#123;</span><br><span class="line">     Entry[] <span class="keyword">tab</span> = <span class="keyword">table</span>;</span><br><span class="line">     int len = <span class="keyword">tab</span>.length;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">e</span> != null) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = <span class="keyword">e</span>.<span class="literal">get</span>();</span><br><span class="line">         <span class="keyword">if</span> (k == key)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">e</span>;</span><br><span class="line">         <span class="keyword">if</span> (k == null)</span><br><span class="line">             expungeStaleEntry(i);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             i = nextIndex(i, len);</span><br><span class="line">         <span class="keyword">e</span> = <span class="keyword">tab</span>[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>expungeStaleEntry</code>函数的源码：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">           Entry[] <span class="keyword">tab</span> = <span class="keyword">table</span>;</span><br><span class="line">           int len = <span class="keyword">tab</span>.length;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">           <span class="keyword">tab</span>[staleSlot].value = null;</span><br><span class="line">           <span class="keyword">tab</span>[staleSlot] = null;</span><br><span class="line">           size--;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">           Entry <span class="keyword">e</span>;</span><br><span class="line">           int i;</span><br><span class="line">           <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                (<span class="keyword">e</span> = <span class="keyword">tab</span>[i]) != null;</span><br><span class="line">                i = nextIndex(i, len)) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = <span class="keyword">e</span>.<span class="literal">get</span>();</span><br><span class="line">               <span class="keyword">if</span> (k == null) &#123;</span><br><span class="line">                   <span class="keyword">e</span>.value = null;</span><br><span class="line">                   <span class="keyword">tab</span>[i] = null;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   int <span class="keyword">h</span> = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">h</span> != i) &#123;</span><br><span class="line">                       <span class="keyword">tab</span>[i] = null;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                       <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                       <span class="keyword">while</span> (<span class="keyword">tab</span>[<span class="keyword">h</span>] != null)</span><br><span class="line">                           <span class="keyword">h</span> = nextIndex(<span class="keyword">h</span>, len);</span><br><span class="line">                       <span class="keyword">tab</span>[<span class="keyword">h</span>] = <span class="keyword">e</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>整理一下ThreadLocalMap的<code>getEntry</code>函数的流程：</p>
<ol>
<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>
<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>
</ol>
<p>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，<code>set</code>操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。<br>但是光这样还是不够的，上面的设计思路依赖一个前提条件：<strong>要调用ThreadLocalMap的<code>genEntry</code>函数或者<code>set</code>函数。</strong>这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的<code>remove</code>函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p>
<h1 id="声明">声明</h1><p>本文为作者自己的个人见解，如理解有误，请留言相告，谢谢。<br><strong>转载请注明出处：</strong><br><a href="http://fudawei.github.io/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/">http://fudawei.github.io/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>相信读者在网上也看了很多关于ThreadLocal的资料，很多博客都这样说：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。如果你也这样认为的，那现在给你10秒钟，清空之前对ThreadLocal的<strong>错误</strong>的认知！<br>]]>
    
    </summary>
    
      <category term="Java并发包学习" scheme="http://fudawei.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Java并发包学习" scheme="http://fudawei.github.io/categories/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[A记录和CNAME记录介绍]]></title>
    <link href="http://fudawei.github.io/2015/08/31/A%E8%AE%B0%E5%BD%95%E4%B8%8ECNAME%E8%AE%B0%E5%BD%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fudawei.github.io/2015/08/31/A记录与CNAME记录介绍/</id>
    <published>2015-08-31T08:12:41.000Z</published>
    <updated>2015-12-30T06:02:16.172Z</updated>
    <content type="html"><![CDATA[<h1 id="域名解析">域名解析</h1><p>在互联网上访问网站的时候我们通常都是输入网址，比如<a href="http://fudawei.github.io">http://fudawei.github.io</a>，通过这个网址怎么知道需要访问的资源是在哪里呢？答案就是域名解析，将一个网址映射到一个特定的IP地址的过程就叫做<strong>域名解析</strong>。域名的解析工作由DNS服务器完成。<br><a id="more"></a></p>
<h1 id="A记录">A记录</h1><p>A记录即Address记录，字面意思就是地址记录，就是将一个域名或主机名解析成一个具体的IP地址。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。</p>
<h1 id="CNAME记录">CNAME记录</h1><p>CNAME记录即别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就 <a href="http://www.mydomain.com/和“mail.mydomain.com”。实际上他们都指向" target="_blank" rel="external">http://www.mydomain.com/和“mail.mydomain.com”。实际上他们都指向</a> “host.mydomain.com”。</p>
<h1 id="A记录和CNAME记录的比较">A记录和CNAME记录的比较</h1><p>A记录就是把一个域名解析到一个IP地址（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个域名。其功能是差不多，CNAME将几个主机名指向一个别名，其实跟指向IP地址是一样的，因为这个别名也要做一个A记录的。但是使用CNAME记录可以很方便地变更IP地址。如果一台服务器有100个网站，他们都做了别名，该台服务器变更IP时，只需要变更别名的A记录就可以了。</p>
<h1 id="使用哪种方式更好">使用哪种方式更好</h1><p>域名解析CNAME记录A记录哪一种比较好？如果论对网站的影响，就没有多大区别。但是：CNAME有一个好处就是稳定，就好像一个IP与一个域名的区别。服务商从方便维护的角度，一般也建议用户使用CNAME记录绑定域名的。如果主机使用了双线IP，显然使用CNAME也要方便一些。<br>A记录也有一些好处，例如可以在输入域名时不用输入WWW.来访问网站哦！从SEO优化角度来看，一些搜索引擎如alex或一些搜索查询工具网站等等则默认是自动去掉WWW.来辨别网站，CNAME记录是必须有如：WWW(别名)前缀的域名，有时候会遇到这样的麻烦，前缀去掉了默认网站无法访问。<br>有人认为，在SEO优化网站的时候，由于搜索引擎找不到去掉WWW.的域名时，对网站权重也会有些影响。因为有些网民客户也是不喜欢多写三个W来访问网站的，网站无法访问有少量网民客户会放弃继续尝试加WWW.访问域名了，因此网站访问浏览量也会减少一些。<br>也有人认为同一个域名加WWW.和不加WWW.访问网站也会使网站权重分散，这也是个问题。但是可以使用301跳转把不加WWW.跳转到加WWW.的域名，问题就解决了。</p>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://blog.xieyc.com/differences-between-a-record-and-cname-record/" target="_blank" rel="external">http://blog.xieyc.com/differences-between-a-record-and-cname-record/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="域名解析">域名解析</h1><p>在互联网上访问网站的时候我们通常都是输入网址，比如<a href="http://fudawei.github.io">http://fudawei.github.io</a>，通过这个网址怎么知道需要访问的资源是在哪里呢？答案就是域名解析，将一个网址映射到一个特定的IP地址的过程就叫做<strong>域名解析</strong>。域名的解析工作由DNS服务器完成。<br>]]>
    
    </summary>
    
      <category term="域名解析" scheme="http://fudawei.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
      <category term="域名解析" scheme="http://fudawei.github.io/categories/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>